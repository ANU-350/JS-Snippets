diff --git a/src/jdk.jfr/share/classes/jdk/jfr/internal/RequestEngine.java b/src/jdk.jfr/share/classes/jdk/jfr/internal/RequestEngine.java
index ff728fbf4f2..9171a4d21f9 100644
--- a/src/jdk.jfr/share/classes/jdk/jfr/internal/RequestEngine.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/internal/RequestEngine.java
@@ -33,6 +33,7 @@ import java.util.Iterator;
 import java.util.List;
 import java.util.Objects;
 import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.concurrent.locks.ReentrantLock;
 import java.util.function.Predicate;
 import jdk.jfr.Event;
 import jdk.jfr.EventType;
@@ -40,6 +41,7 @@ import jdk.jfr.EventType;
 public final class RequestEngine {
 
     private static final JVM jvm = JVM.getJVM();
+    private static final ReentrantLock lock = new ReentrantLock();
 
     static final class RequestHook {
         private final Runnable hook;
@@ -66,7 +68,7 @@ public final class RequestEngine {
                     if (type.isJDK()) {
                         hook.run();
                     } else {
-                        jvm.emitEvent(type.getId(), JVM.counterTime(), 0);
+                        emitJVMEvent(type);
                     }
                     if (Logger.shouldLog(LogTag.JFR_SYSTEM, LogLevel.DEBUG)) {
                         Logger.log(LogTag.JFR_SYSTEM, LogLevel.DEBUG, "Executed periodic hook for " + type.getLogName());
@@ -80,6 +82,18 @@ public final class RequestEngine {
             }
         }
 
+        private void emitJVMEvent(PlatformEventType type) {
+            try {
+                // There should only be one thread in native at a time.
+                // ReentrantLock is used to avoid JavaMonitorBlocked event
+                // from synchronized block.
+                lock.lock();
+                jvm.emitEvent(type.getId(), JVM.counterTime(), 0);
+            } finally {
+                lock.unlock();
+            }
+        }
+
         @SuppressWarnings("removal")
         private void executeSecure() {
             AccessController.doPrivileged(new PrivilegedAction<Void>() {
