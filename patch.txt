diff --git a/make/src/classes/build/tools/jfr/GenerateJfrFiles.java b/make/src/classes/build/tools/jfr/GenerateJfrFiles.java
index 712487ce32b..322ff97d2dd 100644
--- a/make/src/classes/build/tools/jfr/GenerateJfrFiles.java
+++ b/make/src/classes/build/tools/jfr/GenerateJfrFiles.java
@@ -575,7 +575,8 @@ public class GenerateJfrFiles {
             out.write("");
             out.write("class JfrPeriodicEventSet : public AllStatic {");
             out.write(" public:");
-            out.write("  static void requestEvent(JfrEventId id) {");
+            out.write("  static void requestEvent(JfrEventId id, jlong timestamp) {");
+            out.write("    _timestamp = Ticks(timestamp);");
             out.write("    switch(id) {");
             out.write("  ");
             for (TypeElement e : metadata.getPeriodicEvents()) {
@@ -595,6 +596,8 @@ public class GenerateJfrFiles {
                 out.write("  static void request" + e.name + "(void);");
                 out.write("");
             }
+            out.write(" static Ticks timestamp(void);");
+            out.write(" static Ticks _timestamp;");
             out.write("};");
             out.write("");
             out.write("#endif // INCLUDE_JFR");
diff --git a/src/hotspot/share/jfr/jni/jfrJniMethod.cpp b/src/hotspot/share/jfr/jni/jfrJniMethod.cpp
index 8ae2eb0c276..22f76852bee 100644
--- a/src/hotspot/share/jfr/jni/jfrJniMethod.cpp
+++ b/src/hotspot/share/jfr/jni/jfrJniMethod.cpp
@@ -238,8 +238,8 @@ JVM_ENTRY_NO_ENV(void, jfr_mark_chunk_final(JNIEnv * env, jobject jvm))
   JfrRepository::mark_chunk_final();
 JVM_END
 
-JVM_ENTRY_NO_ENV(jboolean, jfr_emit_event(JNIEnv* env, jobject jvm, jlong eventTypeId, jlong timeStamp, jlong when))
-  JfrPeriodicEventSet::requestEvent((JfrEventId)eventTypeId);
+JVM_ENTRY_NO_ENV(jboolean, jfr_emit_event(JNIEnv* env, jobject jvm, jlong event_type_id, jlong timestamp, jlong when))
+  JfrPeriodicEventSet::requestEvent((JfrEventId)event_type_id, timestamp);
   return thread->has_pending_exception() ? JNI_FALSE : JNI_TRUE;
 JVM_END
 
diff --git a/src/hotspot/share/jfr/periodic/jfrPeriodic.cpp b/src/hotspot/share/jfr/periodic/jfrPeriodic.cpp
index 84512fe731d..365966b8c32 100644
--- a/src/hotspot/share/jfr/periodic/jfrPeriodic.cpp
+++ b/src/hotspot/share/jfr/periodic/jfrPeriodic.cpp
@@ -80,6 +80,13 @@
  */
 #define TRACE_REQUEST_FUNC(id)    void JfrPeriodicEventSet::request##id(void)
 
+// Timestamp to correlate events in the same batch/generation
+Ticks JfrPeriodicEventSet::_timestamp;
+
+Ticks JfrPeriodicEventSet::timestamp(void) {
+  return _timestamp;
+}
+
 TRACE_REQUEST_FUNC(JVMInformation) {
   ResourceMark rm;
   EventJVMInformation event;
diff --git a/src/hotspot/share/utilities/ticks.hpp b/src/hotspot/share/utilities/ticks.hpp
index 969f6792fbe..c9412465677 100644
--- a/src/hotspot/share/utilities/ticks.hpp
+++ b/src/hotspot/share/utilities/ticks.hpp
@@ -231,6 +231,8 @@ class TimeInstant : public Rep<TimeSource> {
   friend class GranularTimer;
   friend class ObjectSample;
   friend class EventEmitter;
+  friend class JfrPeriodicEventSet;
+
   // GC unit tests
   friend class TimePartitionsTest;
   friend class GCTimerTest;
diff --git a/src/jdk.jfr/share/classes/jdk/jfr/internal/RequestEngine.java b/src/jdk.jfr/share/classes/jdk/jfr/internal/RequestEngine.java
index 2958e585893..f5f50f56522 100644
--- a/src/jdk.jfr/share/classes/jdk/jfr/internal/RequestEngine.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/internal/RequestEngine.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016, 2021, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2022, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -33,6 +33,7 @@ import java.util.Iterator;
 import java.util.List;
 import java.util.Objects;
 import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.locks.ReentrantLock;
 import java.util.function.Predicate;
 import jdk.jfr.Event;
@@ -42,7 +43,6 @@ public final class RequestEngine {
 
     private static final JVM jvm = JVM.getJVM();
     private static final ReentrantLock lock = new ReentrantLock();
-
     static final class RequestHook {
         private final Runnable hook;
         private final PlatformEventType type;
@@ -62,13 +62,13 @@ public final class RequestEngine {
             this(null, eventType, null);
         }
 
-        private void execute() {
+        private void execute(long timestamp) {
             try {
                 if (accessControllerContext == null) { // native
                     if (type.isJDK()) {
                         hook.run();
                     } else {
-                        emitJVMEvent(type);
+                        emitJVMEvent(type, timestamp);
                     }
                     if (Logger.shouldLog(LogTag.JFR_SYSTEM, LogLevel.DEBUG)) {
                         Logger.log(LogTag.JFR_SYSTEM, LogLevel.DEBUG, "Executed periodic hook for " + type.getLogName());
@@ -82,13 +82,13 @@ public final class RequestEngine {
             }
         }
 
-        private void emitJVMEvent(PlatformEventType type) {
+        private void emitJVMEvent(PlatformEventType type, long timestamp) {
             try {
                 // There should only be one thread in native at a time.
                 // ReentrantLock is used to avoid JavaMonitorBlocked event
                 // from synchronized block.
                 lock.lock();
-                jvm.emitEvent(type.getId(), JVM.counterTime(), 0);
+                jvm.emitEvent(type.getId(), timestamp, 0);
             } finally {
                 lock.unlock();
             }
@@ -191,20 +191,21 @@ public final class RequestEngine {
     }
 
     private static void doChunk(Predicate<PlatformEventType> predicate) {
+        long timestamp = JVM.counterTime();
         for (RequestHook requestHook : entries) {
             PlatformEventType s = requestHook.type;
             if (s.isEnabled() && predicate.test(s)) {
-                requestHook.execute();
+                requestHook.execute(timestamp);
             }
         }
     }
 
     static long doPeriodic() {
-        return run_requests(entries);
+        return run_requests(entries, JVM.counterTime());
     }
 
     // code copied from native impl.
-    private static long run_requests(Collection<RequestHook> entries) {
+    private static long run_requests(Collection<RequestHook> entries, long timestamp) {
         long last = lastTimeMillis;
         // Bug 9000556 - current time millis has rather lame resolution
         // The use of os::elapsed_counter() is deliberate here, we don't
@@ -249,7 +250,7 @@ public final class RequestEngine {
                 // Bug 9000556 - don't try to compensate
                 // for wait > period
                 r_delta = 0;
-                he.execute();
+                he.execute(timestamp);
             }
 
             // calculate time left
