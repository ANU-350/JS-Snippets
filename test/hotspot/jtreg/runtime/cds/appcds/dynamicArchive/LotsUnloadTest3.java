/*
 * Copyright (c) 2021, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 *
 */

/*
 * @test
 * @bug 8278602
 * @summary Lots of classes being unloaded while we try to dump a dynamic archive
 * @library /test/lib 
 *          /test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/test-classes
 * @build LotsUnloadApp
 * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar LotsUnloadApp.jar LotsUnloadApp DefinedAsHiddenKlass
 * @test LotsUnloadTest1
 * @run main/othervm -XX:+UnlockDiagnosticVMOptions -XX:-UseCompressedOops -Xbootclasspath/a:. LotsUnloadTest3
 */



/*
 * @test
 * @bug 8278602
 * @summary Lots of classes being unloaded while we try to dump a dynamic archive
 * @library /test/lib 
 *          /test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/test-classes
 * @build LotsUnloadApp
 * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar LotsUnloadApp.jar LotsUnloadApp DefinedAsHiddenKlass
 * @test LotsUnloadTest1
 * @run main/othervm -XX:+UnlockDiagnosticVMOptions -XX:-UseCompressedOops -Xbootclasspath/a:. LotsUnloadTest3
 */
 
/*
 * @test
 * @bug 8278602
 * @summary Lots of classes being unloaded while we try to dump a dynamic archive
 * @library /test/lib 
 *          /test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/test-classes
 * @build LotsUnloadApp
 * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar LotsUnloadApp.jar LotsUnloadApp DefinedAsHiddenKlass
 * @test LotsUnloadTest1
 * @run main/othervm -XX:+UnlockDiagnosticVMOptions -XX:-UseCompressedOops -Xbootclasspath/a:. LotsUnloadTest3
 */
 /*
 * @test
 * @bug 8278602
 * @summary Lots of classes being unloaded while we try to dump a dynamic archive
 * @library /test/lib 
 *          /test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/test-classes
 * @build LotsUnloadApp
 * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar LotsUnloadApp.jar LotsUnloadApp DefinedAsHiddenKlass
 * @test LotsUnloadTest1
 * @run main/othervm -XX:+UnlockDiagnosticVMOptions -XX:-UseCompressedOops -Xbootclasspath/a:. LotsUnloadTest3
 */
 /*
 * @test
 * @bug 8278602
 * @summary Lots of classes being unloaded while we try to dump a dynamic archive
 * @library /test/lib 
 *          /test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/test-classes
 * @build LotsUnloadApp
 * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar LotsUnloadApp.jar LotsUnloadApp DefinedAsHiddenKlass
 * @test LotsUnloadTest1
 * @run main/othervm -XX:+UnlockDiagnosticVMOptions -XX:-UseCompressedOops -Xbootclasspath/a:. LotsUnloadTest3
 */
 /*
 * @test
 * @bug 8278602
 * @summary Lots of classes being unloaded while we try to dump a dynamic archive
 * @library /test/lib 
 *          /test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/test-classes
 * @build LotsUnloadApp
 * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar LotsUnloadApp.jar LotsUnloadApp DefinedAsHiddenKlass
 * @test LotsUnloadTest1
 * @run main/othervm -XX:+UnlockDiagnosticVMOptions -XX:-UseCompressedOops -Xbootclasspath/a:. LotsUnloadTest3
 */
 /*
 * @test
 * @bug 8278602
 * @summary Lots of classes being unloaded while we try to dump a dynamic archive
 * @library /test/lib 
 *          /test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/test-classes
 * @build LotsUnloadApp
 * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar LotsUnloadApp.jar LotsUnloadApp DefinedAsHiddenKlass
 * @test LotsUnloadTest1
 * @run main/othervm -XX:+UnlockDiagnosticVMOptions -XX:-UseCompressedOops -Xbootclasspath/a:. LotsUnloadTest3
 */
 /*
 * @test
 * @bug 8278602
 * @summary Lots of classes being unloaded while we try to dump a dynamic archive
 * @library /test/lib 
 *          /test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/test-classes
 * @build LotsUnloadApp
 * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar LotsUnloadApp.jar LotsUnloadApp DefinedAsHiddenKlass
 * @test LotsUnloadTest1
 * @run main/othervm -XX:+UnlockDiagnosticVMOptions -XX:-UseCompressedOops -Xbootclasspath/a:. LotsUnloadTest3
 */
 /*
 * @test
 * @bug 8278602
 * @summary Lots of classes being unloaded while we try to dump a dynamic archive
 * @library /test/lib 
 *          /test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/test-classes
 * @build LotsUnloadApp
 * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar LotsUnloadApp.jar LotsUnloadApp DefinedAsHiddenKlass
 * @test LotsUnloadTest1
 * @run main/othervm -XX:+UnlockDiagnosticVMOptions -XX:-UseCompressedOops -Xbootclasspath/a:. LotsUnloadTest3
 */
 /*
 * @test
 * @bug 8278602
 * @summary Lots of classes being unloaded while we try to dump a dynamic archive
 * @library /test/lib 
 *          /test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/test-classes
 * @build LotsUnloadApp
 * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar LotsUnloadApp.jar LotsUnloadApp DefinedAsHiddenKlass
 * @test LotsUnloadTest1
 * @run main/othervm -XX:+UnlockDiagnosticVMOptions -XX:-UseCompressedOops -Xbootclasspath/a:. LotsUnloadTest3
 */
 /*
 * @test
 * @bug 8278602
 * @summary Lots of classes being unloaded while we try to dump a dynamic archive
 * @library /test/lib 
 *          /test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/test-classes
 * @build LotsUnloadApp
 * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar LotsUnloadApp.jar LotsUnloadApp DefinedAsHiddenKlass
 * @test LotsUnloadTest1
 * @run main/othervm -XX:+UnlockDiagnosticVMOptions -XX:-UseCompressedOops -Xbootclasspath/a:. LotsUnloadTest3
 */
 /*
 * @test
 * @bug 8278602
 * @summary Lots of classes being unloaded while we try to dump a dynamic archive
 * @library /test/lib 
 *          /test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/test-classes
 * @build LotsUnloadApp
 * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar LotsUnloadApp.jar LotsUnloadApp DefinedAsHiddenKlass
 * @test LotsUnloadTest1
 * @run main/othervm -XX:+UnlockDiagnosticVMOptions -XX:-UseCompressedOops -Xbootclasspath/a:. LotsUnloadTest3
 */
 /*
 * @test
 * @bug 8278602
 * @summary Lots of classes being unloaded while we try to dump a dynamic archive
 * @library /test/lib 
 *          /test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/test-classes
 * @build LotsUnloadApp
 * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar LotsUnloadApp.jar LotsUnloadApp DefinedAsHiddenKlass
 * @test LotsUnloadTest1
 * @run main/othervm -XX:+UnlockDiagnosticVMOptions -XX:-UseCompressedOops -Xbootclasspath/a:. LotsUnloadTest3
 */
 

// Note: for https://bugs.openjdk.java.net/browse/JDK-8278602, this test case does NOT
// reliably reproduce the problem. Reproduction requires patching ZGC. Please see
// the bug report for instructions.
//
// This test case is included so that it may find a similar bug under stress conditions
// in the CI runs.

import java.io.File;
import java.io.FileOutputStream;
import java.io.PrintStream;
import jdk.test.lib.process.OutputAnalyzer;
import jdk.test.lib.process.ProcessTools;
import jdk.test.lib.helpers.ClassFileInstaller;

// This class represents options used
// during creation of CDS archive and/or running JVM with a CDS archive
class CDSOptions {
    public String xShareMode = "on";

    public CDSOptions() {
    }

    public CDSOptions setXShareMode(String mode) {
        this.xShareMode = mode;
        return this;
    }
}

    interface Checker {
        public void check(OutputAnalyzer output) throws Exception;
    }

    class Result {
    public static final String MSG_RANGE_NOT_WITHIN_HEAP =
        "UseSharedSpaces: Unable to allocate region, range is not within java heap.";
    public static final String MSG_RANGE_ALREADT_IN_USE =
        "Unable to allocate region, java heap range is already in use.";
    public static final String MSG_DYNAMIC_NOT_SUPPORTED =
        "-XX:ArchiveClassesAtExit is unsupported when base CDS archive is not loaded";
    public static final boolean DYNAMIC_DUMP = Boolean.getBoolean("test.dynamic.cds.archive");
        private final OutputAnalyzer output;
        private final CDSOptions options;
        private final boolean hasNormalExit;
        private final String CDS_DISABLED = "warning: CDS is disabled when the";

        public Result(CDSOptions opts, OutputAnalyzer out) throws Exception {
            checkMappingFailure(out);
            this.options = opts;
            this.output = out;
            hasNormalExit = (output.getExitValue() == 0);

            if (hasNormalExit) {
                if ("on".equals(options.xShareMode) &&
                    output.getStderr().contains("java version") &&
                    !output.getStderr().contains(CDS_DISABLED)) {
                    // "-showversion" is always passed in the command-line by the execXXX methods.
                    // During normal exit, we require that the VM to show that sharing was enabled.
                    output.shouldContain("sharing");
                }
            }
        }

        public Result assertNormalExit(Checker checker) throws Exception {
            checker.check(output);
            output.shouldHaveExitValue(0);
            return this;
        }

        public Result assertNormalExit(String... matches) throws Exception {
            checkMatches(output, matches);
            output.shouldHaveExitValue(0);
            return this;
        }

    private static String hasUnableToMapMessage(OutputAnalyzer output) {
        String outStr = output.getOutput();
        if ((output.getExitValue() == 1)) {
            if (outStr.contains(MSG_RANGE_NOT_WITHIN_HEAP)) {
                return MSG_RANGE_NOT_WITHIN_HEAP;
            }
            if (outStr.contains(MSG_DYNAMIC_NOT_SUPPORTED)) {
                return MSG_DYNAMIC_NOT_SUPPORTED;
            }
        }

        return null;
    }

    public static boolean isUnableToMap(OutputAnalyzer output) {
        return hasUnableToMapMessage(output) != null;
    }

    public static void checkMappingFailure(OutputAnalyzer out) throws Exception {
        String match = hasUnableToMapMessage(out);
        if (match != null) {
            throw new Exception("Unable to map shared archive: test did not complete" + ": " + match);
        }
    }
    public static OutputAnalyzer checkMatches(OutputAnalyzer output,
                                              String... matches) throws Exception {
        for (String match : matches) {
            output.shouldContain(match);
        }
        return output;
    }
    }

public class LotsUnloadTest3 {
    private static boolean executedIn_run = false;

    public static void main(String[] args) throws Exception {
        runTest();
    }

    public static void runTest() throws Exception {
        executedIn_run = true;
        try {
            deletePriorArchives();
            test();
        } finally {
            executedIn_run = false;
        }
    }
    
    public static void deletePriorArchives() {
        File dir = outputDirAsFile;
        String files[] = dir.list();
        for (String name : files) {
            if (name.startsWith("appcds-") && name.endsWith(".jsa")) {
                if (!(new File(dir, name)).delete())
                    System.out.println("deletePriorArchives(): delete failed for file " + name);
            }
        }
    }


    public static Result dump(String ... cmdLineSuffix) throws Exception
    {
        return execProcess("dump", cmdLineSuffix);
    }

    public static Result run(String ... cmdLineSuffix) throws Exception
    {
        return execProcess("exec", cmdLineSuffix);
    }

    private static int getNextLogCounter() {
        return logCounter++;
    }

    static int logCounter = 0;

    public static File getOutputFile(String name) {
        return new File(outputDirAsFile, testName + "-" + name);
    }
    public static final String TEST_NAME = System.getProperty("test.name", ".");
    private static String testName = TEST_NAME.replace('/', '.');

    static File outputDirAsFile;
    static String outputDir;

    static {
        outputDir = System.getProperty("user.dir", ".");
        outputDirAsFile = new File(outputDir);
    }

    public static final boolean copyChildStdoutToMainStdout =
        Boolean.getBoolean("test.cds.copy.child.stdout");

    public static OutputAnalyzer executeAndLog(ProcessBuilder pb, String logName) throws Exception {
        long started = System.currentTimeMillis();
        OutputAnalyzer output = new OutputAnalyzer(pb.start());
        String logFileNameStem =
            String.format("%04d", getNextLogCounter()) + "-" + logName;

        File stdout = getOutputFile(logFileNameStem + ".stdout");
        File stderr = getOutputFile(logFileNameStem + ".stderr");

        writeFile(stdout, output.getStdout());
        writeFile(stderr, output.getStderr());
        System.out.println("[ELAPSED: " + (System.currentTimeMillis() - started) + " ms]");
        System.out.println("[logging stdout to " + stdout + "]");
        System.out.println("[logging stderr to " + stderr + "]");
        System.out.println("[STDERR]\n" + output.getStderr());

        if (copyChildStdoutToMainStdout)
            System.out.println("[STDOUT]\n" + output.getStdout());

        return output;
    }

    private static void writeFile(File file, String content) throws Exception {
        FileOutputStream fos = new FileOutputStream(file);
        PrintStream ps = new PrintStream(fos);
        ps.print(content);
        ps.close();
        fos.close();
    }


    private static Result execProcess(String mode, String[] cmdLine) throws Exception {
        if (!executedIn_run) {
            throw new Exception("Test error: dynamic archive tests must be executed via DynamicArchiveTestBase.run()");
        }
        ProcessBuilder pb = ProcessTools.createTestJvm(cmdLine);

        OutputAnalyzer output = executeAndLog(pb, mode);
        CDSOptions opts = new CDSOptions();
        String xShareMode = getXshareMode(cmdLine);
        if (xShareMode != null) {
            opts.setXShareMode(xShareMode);
        }
        return new Result(opts, output);
    }

    private static String getXshareMode(String[] cmdLine) {
        for (int i = 0; i <= cmdLine.length - 1; i++) {
            int j = cmdLine[i].indexOf("-Xshare:");
            if (j != -1) {
                return (cmdLine[i].substring(j));
            }
        }
        return null;
   }

    static void test() throws Exception {
        String appJar = ClassFileInstaller.getJarPath("LotsUnloadApp.jar");
        String mainClass = "LotsUnloadApp";
        String logging;

        dump("-Xmx64m", "-Xms32m", "-Xlog:gc,gc+marking=trace,cds,gc+verify,class+init", "-XX:-UseCompressedOops",
             "-XX:+UnlockDiagnosticVMOptions -XX:-UseCompressedOops", "-XX:+IgnoreUnrecognizedVMOptions", "-Xshare:off",
//            "-XX:-UseZGC", "-XX:-UseParallelGC", "-XX:-UseG1GC", "-XX:-UseSerialGC",
//            "-XX:+UseParallelGC",
             "-XX:+VerifyDuringGC", "-XX:+VerifyBeforeGC", "-XX:+VerifyAfterGC", "-Xshare:off",
            //"-Xcomp", "-XX:+DeoptimizeALot", "-server", "-XX:CompileThreshold=100", "-XX:-TieredCompilation",
            //"-Xint",
             "-cp", appJar, mainClass)
          .assertNormalExit(output -> {
                output.shouldHaveExitValue(0);
            });

        run("-Xmx64m", "-Xms32m", "-Xlog:gc,gc+phases,gc+marking=debug,cds,gc+verify,class+init", "-XX:-UseCompressedOops",
            "-XX:+UnlockDiagnosticVMOptions -XX:-UseCompressedOops", "-XX:+IgnoreUnrecognizedVMOptions",
            "-Xcomp", "-XX:+DeoptimizeALot", "-server", "-XX:CompileThreshold=100", "-XX:-TieredCompilation", "-Xshare:off",
//            "-XX:-UseZGC", "-XX:-UseParallelGC", "-XX:-UseG1GC", "-XX:-UseSerialGC",
//            "-XX:+UseParallelGC",
            //"-Xint",
            "-XX:+VerifyDuringGC", "-XX:+VerifyBeforeGC", "-XX:+VerifyAfterGC",
            "-cp", appJar, mainClass)
          .assertNormalExit(output -> {
              output.shouldHaveExitValue(0);
            });
    }
}
