#
# Copyright (c) 2011, 2024, Oracle and/or its affiliates. All rights reserved.
# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
#
# This code is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License version 2 only, as
# published by the Free Software Foundation.  Oracle designates this
# particular file as subject to the "Classpath" exception as provided
# by Oracle in the LICENSE file that accompanied this code.
#
# This code is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# version 2 for more details (a copy is included in the LICENSE file that
# accompanied this code).
#
# You should have received a copy of the GNU General Public License version
# 2 along with this work; if not, write to the Free Software Foundation,
# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
#
# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
# or visit www.oracle.com if you need additional information or have any
# questions.
#

ifeq (,$(_MAKEBASE_GMK))
  $(error You must include MakeBase.gmk prior to including Utils.gmk)
endif

################################################################################
#
# Common utility functions
#
################################################################################

### Debug functions

# Prints the name and value of a variable
PrintVar = \
    $(info $(strip $1) >$($(strip $1))<)


################################################################################
# Strip both arguments. Append the first argument to the second argument. If the
# first argument is empty, return the empty string.
IfAppend = \
    $(if $(strip $1),$(strip $1)$(strip $2),)

################################################################################
# Assign a variable only if it is empty
# Param 1 - Variable to assign
# Param 2 - Value to assign
SetIfEmpty = \
    $(if $($(strip $1)),,$(eval $(strip $1) := $2))

################################################################################
# Filter out duplicate sub strings while preserving order. Keeps the first occurrence.
uniq = \
    $(strip $(if $1,$(firstword $1) $(call uniq,$(filter-out $(firstword $1),$1))))

# Returns all whitespace-separated words in $2 where at least one of the
# whitespace-separated words in $1 is a substring.
containing = \
    $(strip \
        $(foreach v,$(strip $2),\
          $(call uniq,$(foreach p,$(strip $1),$(if $(findstring $p,$v),$v)))))

# Returns all whitespace-separated words in $2 where none of the
# whitespace-separated words in $1 is a substring.
not-containing = \
    $(strip $(filter-out $(call containing,$1,$2),$2))

# Return a list of all string elements that are duplicated in $1.
dups = \
    $(strip $(foreach v, $(sort $1), $(if $(filter-out 1, \
        $(words $(filter $v, $1))), $v)))

# Remove a whole list of prefixes
# $1 - List of prefixes
# $2 - List of elements to process
remove-prefixes = \
    $(strip $(if $1,$(patsubst $(firstword $1)%,%,\
      $(call remove-prefixes,$(filter-out $(firstword $1),$1),$2)),$2))

################################################################################
# Boolean operators.

# Return the word "true" if all the boolean words given as argument is "true",
# and returns "false" otherwise. Boolean words must be "true" or "false". It is
# an error to supply a non-boolean word. An empty string is considered "true".
And = \
  $(strip $(if $(filter-out true false, $1), $(error Non-boolean values: $1)) \
  $(if $(strip $(filter-out true, $1)), false, true))

# Return the word "false" if all the boolean words given as argument is "false",
# and returns "true" otherwise. Boolean words must be "true" or "false". It is
# an error to supply a non-boolean word.  An empty string is considered "false".
Or = \
  $(strip $(if $(filter-out true false, $1), $(error Non-boolean values: $1)) \
  $(if $(strip $(filter-out false, $1)), true, false))


################################################################################
# Convert an UNIX epoch based timestamp (as an integer) to an ISO 8601 date
# string.
# Param 1 - timestamp
ifeq ($(IS_GNU_DATE), yes)
  EpochToISO8601 = \
    $(shell $(DATE) --utc --date="@$(strip $1)" \
         +"$(ISO_8601_FORMAT_STRING)" 2> /dev/null)
else
  EpochToISO8601 = \
    $(shell $(DATE) -u -j -f "%s" "$(strip $1)" \
         +"$(ISO_8601_FORMAT_STRING)" 2> /dev/null)
endif

################################################################################
# Parse a multiple-keyword variable, like FOO="KEYWORD1=val1;KEYWORD2=val2;..."
# These will be converted into a series of variables like FOO_KEYWORD1=val1,
# FOO_KEYWORD2=val2, etc. Unknown keywords will cause an error.
#
# Parameter 1 is the name of the rule, and is also the name of the variable.
#
# Remaining parameters are named arguments. These include:
#   SINGLE_KEYWORDS   A list of valid keywords with single string values
#   STRING_KEYWORDS   A list of valid keywords, processed as string. This means
#       that '%20' will be replaced by ' ' to allow for multi-word strings.
#
ParseKeywordVariable = $(NamedParamsMacroTemplate)
define ParseKeywordVariableBody
  ifneq ($$($1), )
    # To preserve spaces, substitute them with a hopefully unique pattern
    # before splitting and then re-substitute spaces back.
    $1_MANGLED := $$(subst $$(SPACE),||||,$$($1))
    $$(foreach mangled_part, $$(subst ;, , $$($1_MANGLED)), \
      $$(eval mangled_part_eval := $$(call DoubleDollar, $$(mangled_part))) \
      $$(eval part := $$$$(subst ||||,$$$$(SPACE),$$$$(mangled_part_eval))) \
      $$(eval $1_NO_MATCH := true) \
      $$(if $$(filter help, $$(part)), \
        $$(info Valid keywords for $1:) \
        $$(info $$($1_SINGLE_KEYWORDS) $$($1_STRING_KEYWORDS).) \
        $$(error Re-run without 'help' to continue)) \
      $$(foreach keyword, $$($1_SINGLE_KEYWORDS), \
        $$(eval keyword_eval := $$(call DoubleDollar, $$(keyword))) \
        $$(if $$(filter $$(keyword)=%, $$(part)), \
          $$(eval $(strip $1)_$$$$(keyword_eval) := $$$$(strip $$$$(patsubst $$$$(keyword_eval)=%, %, $$$$(part)))) \
          $$(eval $1_NO_MATCH := ) \
        ) \
      ) \
      $$(foreach keyword, $$($1_STRING_KEYWORDS), \
        $$(eval keyword_eval := $$(call DoubleDollar, $$(keyword))) \
        $$(if $$(filter $$(keyword)=%, $$(part)), \
          $$(eval $(strip $1)_$$$$(keyword_eval) := $$$$(strip $$$$(subst %20, , $$$$(patsubst $$$$(keyword_eval)=%, %, $$$$(part))))) \
          $$(eval $1_NO_MATCH := ) \
        ) \
      ) \
      $$(if $$($1_NO_MATCH), \
        $$(if $$(filter $$(part), $$($1_SINGLE_KEYWORDS) $$($1_STRING_KEYWORDS)), \
          $$(info Keyword $$(part) for $1 needs to be assigned a value.) \
        , \
          $$(info $$(part) is not a valid keyword for $1.) \
          $$(info Valid keywords: $$($1_SINGLE_KEYWORDS) $$($1_STRING_KEYWORDS).) \
        ) \
        $$(error Cannot continue) \
      ) \
    )
  endif
endef

################################################################################
# Find lib dir for module
# Param 1 - module name
FindLibDirForModule = \
    $(SUPPORT_OUTPUTDIR)/modules_libs/$(strip $1)

################################################################################
# Find executable dir for module
# Param 1 - module name
FindExecutableDirForModule = \
    $(SUPPORT_OUTPUTDIR)/modules_cmds/$(strip $1)

################################################################################
# Return a string suitable for use after a -classpath or --module-path option. It
# will be correct and safe to use on all platforms. Arguments are given as space
# separate classpath entries. Safe for multiple nested calls.
# param 1 : A space separated list of classpath entries
# The surrounding strip is needed to keep additional whitespace out
PathList = \
  "$(subst $(SPACE),:,$(strip $(subst $(DQUOTE),,$1)))"

################################################################################
# Check if a specified hotspot variant is being built, or at least one of a
# list of variants. Will return 'true' or 'false'.
# $1 - the variant to test for
check-jvm-variant = \
  $(strip \
    $(if $(filter-out $(VALID_JVM_VARIANTS), $1), \
      $(error Internal error: Invalid variant tested: $1)) \
    $(if $(filter $1, $(JVM_VARIANTS)), true, false))

################################################################################
# Converts a space separated list to a comma separated list.
#
# Replacing double-comma with a single comma is to workaround the issue with
# some version of make on windows that doesn't substitute spaces with one comma
# properly.
CommaList = \
  $(strip \
      $(subst $(COMMA)$(COMMA),$(COMMA),$(subst $(SPACE),$(COMMA),$(strip $1))) \
  )

################################################################################
# Converts a space separated list to a colon separated list.
#
# Replacing double-colon with a single colon is to workaround the issue with
# some version of make on windows that doesn't substitute spaces with one colon
# properly.
ColonList = \
  $(strip \
      $(subst ::,:,$(subst $(SPACE),:,$(strip $1))) \
  )

################################################################################
# Given a list of files, filters out locale specific files for translations
# that should be excluded from this build.
# $1 - The list of files to filter
# $2 - The suffix of the files that should be considered (.java or .properties)
FilterExcludedTranslations = \
  $(strip $(if $(EXCLUDE_TRANSLATIONS), \
    $(filter-out \
        $(foreach suffix, $2, \
          $(addprefix %_, $(addsuffix $(suffix), $(EXCLUDE_TRANSLATIONS))) \
        ), \
        $1 \
    ), \
    $1 \
  ))
