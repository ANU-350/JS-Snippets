#
# Copyright (c) 2011, 2024, Oracle and/or its affiliates. All rights reserved.
# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
#
# This code is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License version 2 only, as
# published by the Free Software Foundation.  Oracle designates this
# particular file as subject to the "Classpath" exception as provided
# by Oracle in the LICENSE file that accompanied this code.
#
# This code is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# version 2 for more details (a copy is included in the LICENSE file that
# accompanied this code).
#
# You should have received a copy of the GNU General Public License version
# 2 along with this work; if not, write to the Free Software Foundation,
# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
#
# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
# or visit www.oracle.com if you need additional information or have any
# questions.
#

ifeq (,$(_MAKEBASE_GMK))
  $(error You must include MakeBase.gmk prior to including BaseUtils.gmk)
endif

################################################################################
#
# Basic utility functions available to MakeBase.gmk itself
#
################################################################################

# String equals
equals = \
    $(if $(strip $1)$(strip $2),$(strip \
      $(and $(findstring $(strip $1),$(strip $2)),\
        $(findstring $(strip $2),$(strip $1)))), \
      true \
    )

# Convert the string given to upper case, without any $(shell)
# Inspired by http://lists.gnu.org/archive/html/help-make/2013-09/msg00009.html
uppercase_table := a,A b,B c,C d,D e,E f,F g,G h,H i,I j,J k,K l,L m,M n,N o,O \
    p,P q,Q r,R s,S t,T u,U v,V w,W x,X y,Y z,Z

uppercase_internal = \
  $(if $(strip $1), $$(subst $(firstword $1), $(call uppercase_internal, \
      $(wordlist 2, $(words $1), $1), $2)), $2)

# Convert a string to upper case. Works only on a-z.
# $1 - The string to convert
uppercase = \
  $(strip \
    $(eval uppercase_result := $(call uppercase_internal, $(uppercase_table), $1)) \
    $(uppercase_result) \
  )

################################################################################
# Creates a sequence of increasing numbers (inclusive).
# Param 1 - starting number
# Param 2 - ending number
sequence = \
    $(wordlist $1, $2, $(strip \
        $(eval SEQUENCE_COUNT :=) \
        $(call _sequence-do,$(strip $2))))

_sequence-do = \
    $(if $(word $1, $(SEQUENCE_COUNT)),, \
      $(eval SEQUENCE_COUNT += .) \
      $(words $(SEQUENCE_COUNT)) \
      $(call _sequence-do,$1))

################################################################################
# This macro translates $ into \$ to protect the $ from expansion in the shell.
# To make this macro resilient against already escaped strings, first remove
# any present escapes before escaping so that no double escapes are added.
EscapeDollar = $(subst $$,\$$,$(subst \$$,$$,$(strip $1)))

################################################################################
# This macro works just like EscapeDollar above, but for #.
EscapeHash = $(subst \#,\\\#,$(subst \\\#,\#,$(strip $1)))

################################################################################
# This macro translates $ into $$ to protect the string from make itself.
DoubleDollar = $(subst $$,$$$$,$(strip $1))

################################################################################
# ShellQuote
#
# Quotes a string with single quotes and replaces single quotes with '\'' so
# that the contents survives being given to the shell.
ShellQuote = \
    $(SQUOTE)$(subst $(SQUOTE),$(SQUOTE)\$(SQUOTE)$(SQUOTE),$(strip $1))$(SQUOTE)

################################################################################
# Write to and read from file

# Param 1 - File to read
ReadFile = \
    $(shell $(CAT) $1)

# Param 1 - Text to write
# Param 2 - File to write to
ifeq ($(HAS_FILE_FUNCTION), true)
  WriteFile = \
      $(file >$2,$(strip $1))
else
  # Use printf to get consistent behavior on all platforms.
  WriteFile = \
      $(shell $(PRINTF) "%s\n" $(strip $(call ShellQuote, $1)) > $2)
endif

# Param 1 - Text to write
# Param 2 - File to write to
ifeq ($(HAS_FILE_FUNCTION), true)
  AppendFile = \
      $(file >>$2,$(strip $1))
else
  # Use printf to get consistent behavior on all platforms.
  AppendFile = \
      $(shell $(PRINTF) "%s\n" $(strip $(call ShellQuote, $1)) >> $2)
endif

################################################################################
# Make directory without forking mkdir if not needed.
#
# If a directory with an encoded space is provided, the wildcard function
# sometimes returns false answers (typically if the dir existed when the
# makefile was parsed, but was deleted by a previous rule). In that case, always
# call mkdir regardless of what wildcard says.
#
# 1: List of directories to create
MakeDir = \
    $(strip \
        $(eval MakeDir_dirs_to_make := $(strip $(foreach d, $1, \
          $(if $(findstring ?, $d), '$(call DecodeSpace, $d)', \
            $(if $(wildcard $d), , $d) \
          ) \
        ))) \
        $(if $(MakeDir_dirs_to_make), $(shell $(MKDIR) -p $(MakeDir_dirs_to_make))) \
    )

################################################################################
# Check if our build or target conforms to certain restrictions. This set of
# functions all work in similar ways, testing the property that the name
# implies, so e.g. isTargetCpu test the CPU of the target system.
#
# $1 - A property, or a space separated list of properties to test for.
#
# Returns true if the actual property matches one of the properties in the list,
# and false otherwise.
#
# Examples: $(call isTargetOs, linux windows) will return true when executed
# on either linux or windows, and false otherwise.
# $(call isBuildCpuArch, x86) will return true iff the build CPU Arch is x86.

isTargetOs = \
  $(strip $(if $(filter $(OPENJDK_TARGET_OS), $1), true, false))

isTargetOsType = \
  $(strip $(if $(filter $(OPENJDK_TARGET_OS_TYPE), $1), true, false))

isTargetCpu = \
  $(strip $(if $(filter $(OPENJDK_TARGET_CPU), $1), true, false))

isTargetCpuArch = \
  $(strip $(if $(filter $(OPENJDK_TARGET_CPU_ARCH), $1), true, false))

isTargetCpuBits = \
  $(strip $(if $(filter $(OPENJDK_TARGET_CPU_BITS), $1), true, false))

isBuildOs = \
  $(strip $(if $(filter $(OPENJDK_BUILD_OS), $1), true, false))

isBuildOsType = \
  $(strip $(if $(filter $(OPENJDK_BUILD_OS_TYPE), $1), true, false))

isBuildOsEnv = \
  $(strip $(if $(filter $(OPENJDK_BUILD_OS_ENV), $1), true, false))

isBuildCpu = \
  $(strip $(if $(filter $(OPENJDK_BUILD_CPU), $1), true, false))

isBuildCpuArch = \
  $(strip $(if $(filter $(OPENJDK_BUILD_CPU_ARCH), $1), true, false))

isCompiler = \
  $(strip $(if $(filter $(TOOLCHAIN_TYPE), $1), true, false))
