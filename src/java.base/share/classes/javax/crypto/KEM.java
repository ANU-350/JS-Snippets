/*
 * Copyright (c) 2023, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the "Classpath" exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package javax.crypto;

import sun.security.jca.GetInstance;

import java.security.*;
import java.security.InvalidAlgorithmParameterException;
import java.security.spec.AlgorithmParameterSpec;
import java.util.List;
import java.util.Objects;

/**
 * The Key Encapsulation Mechanism.
 * ...
 */
public final class KEM {

    /**
     * Type for the return value of the {@link Encapsulator#encapsulate} method.
     * <p>
     * Note: the key encapsulation message can be also referred to as ciphertext.
     *
     * @param key the shared secret as a key, must not be {@code null}
     * @param encapsulation the key encapsulation message to be sent to the
     *                      receiver, must not be {@code null}
     * @param params additional parameters to be sent to the receiver,
     *               can be {@code null}. The parameters can be used to
     *               initialize an {@code AlgorithmParameters} so that the
     *               receiver may recover the {@code AlgorithmParameterSpec}
     *               used by the encapsulator.
     *
     * @see KEM#newEncapsulator(PublicKey, AlgorithmParameterSpec, SecureRandom)
     */
    public record Encapsulated(SecretKey key, byte[] encapsulation, byte[] params) {
        /**
         * Constructs an {@code Encapsulated} object.
         *
         * @param key the shared secret as a key, must not be {@code null}.
         * @param encapsulation the key encapsulation message, must not be {@code null}.
         * @param params additional parameters, can be {@code null}.
         */
        public Encapsulated {
            Objects.requireNonNull(key);
            Objects.requireNonNull(encapsulation);
        }
    }

    /**
     * A decapsulator, generated by {@link #newDecapsulator}.
     */
    public interface Decapsulator {

        /**
         * The key decapsulation function.
         *
         * @param encapsulation the key encapsulation message from the sender
         * @param from the initial index of the shared secret to be returned, inclusive
         * @param to the final index of the shared secret to be returned, exclusive.
         * @param algorithm the algorithm for the secret key returned
         * @return a portion of the shared secret as a {@code SecretKey} with
         *          the specified algorithm, not {@code null}
         * @throws DecapsulateException if an error occurs during the
         *          decapsulation process
         * @throws ArrayIndexOutOfBoundsException if {@code from < 0},
         *          {@code from > to}, or {@code to > secretSize()}
         * @throws NullPointerException if {@code encapsulation} or
         *          {@code algorithm} is {@code null}
         * @throws UnsupportedOperationException if the combination of
         *          {@code from}, {@code to}, and {@code algorithm}
         *          is not supported by the decapsulator
         */
        SecretKey decapsulate(byte[] encapsulation,
                int from, int to, String algorithm)
                throws DecapsulateException;

        /**
         * The key decapsulation function.
         * <p>
         * This method is equivalent to
         * {@code decapsulate(encapsulation, 0, secretSize(), "Generic")}. This
         * combination of arguments should be supported by every implementation.
         *
         * @param encapsulation the key encapsulation message from the sender
         * @return the shared secret as a {@code SecretKey} with
         *          algorithm being "Generic", not {@code null}
         * @throws DecapsulateException if an error occurs during the
         *          decapsulation process
         * @throws NullPointerException if {@code encapsulation} is {@code null}
         */
        default SecretKey decapsulate(byte[] encapsulation) throws DecapsulateException {
            return decapsulate(encapsulation, 0, secretSize(), "Generic");
        }

        /**
         * Returns the size of the shared secret.
         *
         * @return the size of the shared secret
         */
        int secretSize();

        /**
         * Returns the size of the key encapsulation message.
         *
         * @return the size of the key encapsulation message
         */
        int encapsulationSize();

        /**
         * Returns the provider.
         *
         * @return the provider, or null if it is not bounded to a provider yet.
         */
        default Provider provider() {
            return null;
        }
    }

    /**
     * An encapsulator, generated by {@link #newEncapsulator}.
     */
    public interface Encapsulator {

        /**
         * The key encapsulation function.
         *
         * @param from the initial index of the shared secret to be returned, inclusive
         * @param to the final index of the shared secret to be returned, exclusive.
         * @param algorithm the algorithm for the secret key returned
         * @return an {@link KEM.Encapsulated} object containing a portion of
         *          the shared secret as a key with the specified algorithm,
         *          the key encapsulation message, and optional parameters.
         *          The return value should not be {@code null}.
         * @throws ArrayIndexOutOfBoundsException if {@code from < 0},
         *     {@code from > to}, or {@code to > secretSize()}
         * @throws NullPointerException if {@code algorithm} is {@code null}
         * @throws UnsupportedOperationException if the combination of
         *          {@code from}, {@code to}, and {@code algorithm}
         *          is not supported by the encapsulator
         */
        Encapsulated encapsulate(int from, int to, String algorithm);

        /**
         * The key encapsulation function.
         * <p>
         * This method is equivalent to
         * {@code encapsulate(0, secretSize(), "Generic")}. This combination
         * of arguments should be supported by every implementation.
         *
         * @return an {@link KEM.Encapsulated} object containing the full
         *          shared secret as a key with algorithm being "Generic",
         *          the key encapsulation message, and optional parameters.
         *          The return value should not be {@code null}.
         */
        default KEM.Encapsulated encapsulate() {
            return encapsulate(0, secretSize(), "Generic");
        }

        /**
         * Returns the size of the shared secret.
         *
         * @return the size of the shared secret
         */
        int secretSize();

        /**
         * Returns the size of the key encapsulation message.
         *
         * @return the size of the key encapsulation message
         */
        int encapsulationSize();

        /**
         * Returns the provider.
         *
         * @return the provider, or null if it is not bounded to a provider yet.
         */
        default Provider provider() {
            return null;
        }
    }

    private static final class DelegatedDecapsulator implements Decapsulator {
        private final Provider p;
        private final Decapsulator d;

        private DelegatedDecapsulator(Decapsulator d, Provider p) {
            this.d = d;
            this.p = p;
        }

        @Override
        public SecretKey decapsulate(byte[] encapsulation, int from, int to, String algorithm) throws DecapsulateException {
            return d.decapsulate(encapsulation, from, to, algorithm);
        }

        @Override
        public int secretSize() {
            return d.secretSize();
        }

        @Override
        public int encapsulationSize() {
            return d.encapsulationSize();
        }

        @Override
        public Provider provider() {
            return this.p;
        }
    }

    private static final class DelagatedEncapsulator implements Encapsulator {
        private final Provider p;
        private final Encapsulator e;

        private DelagatedEncapsulator(Encapsulator e, Provider p) {
            this.e = e;
            this.p = p;
        }

        @Override
        public Provider provider() {
            return this.p;
        }

        @Override
        public int encapsulationSize() {
            return e.encapsulationSize();
        }

        @Override
        public int secretSize() {
            return e.secretSize();
        }

        @Override
        public Encapsulated encapsulate(int from, int to, String algorithm) {
            return e.encapsulate(from, to, algorithm);
        }
    }

    private static final class DelayedKEM {

        private final Provider.Service[] list; // non empty array

        private DelayedKEM(Provider.Service[] list) {
            this.list = list;
        }

        private KEM.Encapsulator newEncapsulator(PublicKey pk,
                AlgorithmParameterSpec spec, SecureRandom secureRandom)
                throws InvalidAlgorithmParameterException, InvalidKeyException {
            RuntimeException re = null;
            InvalidAlgorithmParameterException iape = null;
            InvalidKeyException ike = null;
            NoSuchAlgorithmException nsae = null;
            for (Provider.Service service : list) {
                if (!service.supportsParameter(pk)) {
                    continue;
                }
                try {
                    KEMSpi spi = (KEMSpi) service.newInstance(null);
                    return new DelagatedEncapsulator(
                            spi.engineNewEncapsulator(pk, spec, secureRandom),
                            service.getProvider());
                } catch (NoSuchAlgorithmException e) {
                    nsae = merge(nsae, e);
                } catch (InvalidAlgorithmParameterException e) {
                    iape = merge(iape, e);
                } catch (InvalidKeyException e) {
                    ike = merge(ike, e);
                } catch (RuntimeException e) {
                    re = merge(re, e);
                }
            }
            if (iape != null) throw iape;
            if (ike != null) throw ike;
            if (nsae != null) {
                throw new InvalidKeyException("No installed provider found", nsae);
            }
            throw new InvalidKeyException("No installed provider supports this key: "
                            + pk.getClass().getName(), re);
        }

        private static <T extends Exception> T merge(T e1, T e2) {
            if (e1 == null) {
                return e2;
            } else {
                e1.addSuppressed(e2);
                return e1;
            }
        }

        private KEM.Decapsulator newDecapsulator(PrivateKey sk, AlgorithmParameterSpec spec)
                throws InvalidAlgorithmParameterException, InvalidKeyException {
            RuntimeException re = null;
            InvalidAlgorithmParameterException iape = null;
            InvalidKeyException ike = null;
            NoSuchAlgorithmException nsae = null;
            for (Provider.Service service : list) {
                if (!service.supportsParameter(sk)) {
                    continue;
                }
                try {
                    KEMSpi spi = (KEMSpi) service.newInstance(null);
                    return new DelegatedDecapsulator(
                            spi.engineNewDecapsulator(sk, spec),
                            service.getProvider());
                } catch (NoSuchAlgorithmException e) {
                    nsae = merge(nsae, e);
                } catch (InvalidAlgorithmParameterException e) {
                    iape = merge(iape, e);
                } catch (InvalidKeyException e) {
                    ike = merge(ike, e);
                } catch (RuntimeException e) {
                    re = merge(re, e);
                }
            }
            if (iape != null) throw iape;
            if (ike != null) throw ike;
            if (nsae != null) {
                throw new InvalidKeyException("No installed provider found", nsae);
            }
            throw new InvalidKeyException("No installed provider supports this key: "
                    + sk.getClass().getName(), re);
        }
    }

    // If delayed provider selection is needed
    private final DelayedKEM delayed;

    // otherwise
    private final KEMSpi spi;
    private final Provider provider;

    private KEM(KEMSpi spi, Provider provider) {
        assert spi != null;
        assert provider != null;
        this.delayed = null;
        this.spi = spi;
        this.provider = provider;
    }

    private KEM(DelayedKEM delayed) {
        assert delayed != null;
        this.delayed = delayed;
        this.spi = null;
        this.provider = null;
    }

    /**
     * Returns a {@code KEM} object that implements the specified algorithm.
     *
     * @param algorithm the name of the KEM algorithm.
     *          See the {@code KEM} section in the <a href=
     *          "{@docRoot}/../specs/security/standard-names.html#kem-algorithms">
     *          Java Security Standard Algorithm Names Specification</a>
     *          for information about standard KEM algorithm names.
     * @return the new {@code KEM} object
     * @throws NoSuchAlgorithmException if no {@code Provider} supports a
     *         {@code KEM} implementation for the specified algorithm
     * @throws NullPointerException if the input argument is {@code null}
     */
    public static KEM getInstance(String algorithm)
            throws NoSuchAlgorithmException {
        List<Provider.Service> list = GetInstance.getServices(
                "KEM",
                Objects.requireNonNull(algorithm, "null algorithm name"));
        if (list.isEmpty()) {
            throw new NoSuchAlgorithmException(algorithm + " KEM not available");
        }
        return new KEM(new DelayedKEM(list.toArray(new Provider.Service[0])));
    }

    /**
     * Returns a {@code KEM} object that implements the specified algorithm
     * and supports the specified {@code KEMParameterSpec} parameters
     * from the specified security provider.
     *
     * @param algorithm the name of the KEM algorithm.
     *          See the {@code KEM} section in the <a href=
     *          "{@docRoot}/../specs/security/standard-names.html#kem-algorithms">
     *          Java Security Standard Algorithm Names Specification</a>
     *          for information about standard KEM algorithm names.
     * @param provider the provider. If {@code null}, this method is equivalent
     *                 to {@link #getInstance(String)}.
     * @return the new {@code KEM} object
     * @throws NoSuchAlgorithmException if no {@code Provider} supports a
     *         {@code KEM} implementation for the specified algorithm
     * @throws NullPointerException if {@code algorithm} is {@code null}
     */
    public static KEM getInstance(String algorithm, Provider provider)
            throws NoSuchAlgorithmException {
        if (provider == null) {
            return getInstance(algorithm);
        }
        GetInstance.Instance instance = GetInstance.getInstance(
                "KEM",
                KEMSpi.class,
                Objects.requireNonNull(algorithm, "null algorithm name"),
                provider);
        return new KEM((KEMSpi) instance.impl, instance.provider);
    }

    /**
     * Returns a {@code KEM} object that implements the specified algorithm
     * and supports the specified {@code KEMParameterSpec} parameters
     * from the specified security provider.
     *
     * @param algorithm the name of the KEM algorithm.
     *          See the {@code KEM} section in the <a href=
     *          "{@docRoot}/../specs/security/standard-names.html#kem-algorithms">
     *          Java Security Standard Algorithm Names Specification</a>
     *          for information about standard KEM algorithm names.
     * @param provider the provider. If {@code null}, this method is equivalent
     *                 to {@link #getInstance(String)}.
     * @return the new {@code KEM} object
     * @throws NoSuchAlgorithmException if no {@code Provider} supports a
     *         {@code KEM} implementation for the specified algorithm
     * @throws NoSuchProviderException if the specified provider is not
     *         registered in the security provider list
     * @throws NullPointerException if {@code algorithm} is {@code null}
     */
    public static KEM getInstance(String algorithm, String provider)
            throws NoSuchAlgorithmException, NoSuchProviderException {
        if (provider == null) {
            return getInstance(algorithm);
        }
        GetInstance.Instance instance = GetInstance.getInstance(
                "KEM",
                KEMSpi.class,
                Objects.requireNonNull(algorithm, "null algorithm name"),
                provider);
        return new KEM((KEMSpi) instance.impl, instance.provider);
    }

    /**
     * Creates a KEM encapsulator.
     * <p>
     * The method is equivalent to {@code newEncapsulator(pk, null, null)}.
     *
     * @param pk the receiver's public key, must not be {@code null}
     * @return the encapsulator for this key
     * @throws InvalidKeyException if {@code pk} is invalid
     * @throws NullPointerException if {@code pk} is {@code null}
     * @throws UnsupportedOperationException if this method is not supported
     *          and a {@code AlgorithmParameterSpec} must be provided
     */
    public Encapsulator newEncapsulator(PublicKey pk)
            throws InvalidKeyException {
        try {
            return newEncapsulator(pk, null, null);
        } catch (InvalidAlgorithmParameterException e) {
            throw new UnsupportedOperationException(
                    "AlgorithmParameterSpec must be provided", e);
        }
    }

    /**
     * Creates a KEM encapsulator.
     * <p>
     * The method is equivalent to {@code newEncapsulator(pk, null, secureRandom)}.
     *
     * @param pk the receiver's public key, must not be {@code null}
     * @param secureRandom the source of randomness for encapsulation,
     *                     If {@code null}, the implementation should provide
     *                     a default one.
     * @return the encapsulator for this key, not {@code null}
     * @throws InvalidKeyException if {@code pk} is invalid
     * @throws NullPointerException if {@code pk} is {@code null}
     * @throws UnsupportedOperationException if this method is not supported
     *          and a {@code AlgorithmParameterSpec} must be provided
     */
    public Encapsulator newEncapsulator(PublicKey pk, SecureRandom secureRandom)
            throws InvalidKeyException {
        try {
            return newEncapsulator(pk, null, secureRandom);
        } catch (InvalidAlgorithmParameterException e) {
            throw new UnsupportedOperationException(
                    "AlgorithmParameterSpec must be provided", e);
        }
    }

    /**
     * Creates a KEM encapsulator.
     * <p>
     * An algorithm can define an {@code AlgorithmParameterSpec} child class to
     * provide extra information in this method. This is especially useful if
     * the same key can be used to derive shared secrets in different ways.
     * If any extra information inside this object needs to be transmitted along
     * with the key encapsulation message so that the receiver is able to create
     * a matching decapsulator, it will be included as a byte array in the
     * {@link Encapsulated#params} field inside the encapsulation output.
     * In this case, the security provider should provide an
     * {@code AlgorithmParameters} implementation using the same algorithm name
     * as the KEM. The receiver can initiate such an {@code AlgorithmParameters}
     * instance with the {@code params} byte array received and recover
     * an {@code AlgorithmParameterSpec} object to be used in its
     * {@link #newDecapsulator(PrivateKey, AlgorithmParameterSpec)} call.
     *
     * @param pk the receiver's public key, must not be {@code null}
     * @param spec the optional parameter, can be {@code null}
     * @param secureRandom the source of randomness for encapsulation,
     *                     If {@code null}, the implementation should provide
     *                     a default one.
     * @return the encapsulator for this key, not {@code null}
     * @throws InvalidAlgorithmParameterException if {@code spec} is invalid
     *          or one is required but {@code spec} is {@code null}
     * @throws InvalidKeyException if {@code pk} is invalid
     * @throws NullPointerException if {@code pk} is {@code null}
     */
    public Encapsulator newEncapsulator(PublicKey pk,
            AlgorithmParameterSpec spec, SecureRandom secureRandom)
            throws InvalidAlgorithmParameterException, InvalidKeyException {
        Objects.requireNonNull(pk, "null public key");
        return delayed != null
                ? delayed.newEncapsulator(pk, spec, secureRandom)
                : new DelagatedEncapsulator(spi.engineNewEncapsulator(pk, spec, secureRandom), provider);
    }

    /**
     * Creates a KEM decapsulator.
     * <p>
     * The method is equivalent to {@code newDecapsulator(sk, null)}.
     *
     * @param sk the receiver's private key, must not be {@code null}
     * @return the decapsulator for this key, not {@code null}
     * @throws InvalidKeyException if {@code sk} is invalid
     * @throws NullPointerException if {@code sk} is {@code null}
     * @throws UnsupportedOperationException if this method is not supported
     *          and a {@code AlgorithmParameterSpec} must be provided
     */
    public Decapsulator newDecapsulator(PrivateKey sk)
            throws InvalidKeyException {
        try {
            return newDecapsulator(sk, null);
        } catch (InvalidAlgorithmParameterException e) {
            throw new UnsupportedOperationException(e);
        }
    }

    /**
     * Creates a KEM decapsulator.
     *
     * @param sk the receiver's private key, must not be {@code null}
     * @param spec the parameter, can be {@code null}
     * @return the decapsulator for this key, not {@code null}
     * @throws InvalidAlgorithmParameterException if {@code spec} is invalid
     *          or one is required but {@code spec} is {@code null}
     * @throws InvalidKeyException if {@code sk} is invalid
     * @throws NullPointerException if {@code sk} is {@code null}
     */
    public Decapsulator newDecapsulator(PrivateKey sk, AlgorithmParameterSpec spec)
            throws InvalidAlgorithmParameterException, InvalidKeyException {
        Objects.requireNonNull(sk, "null private key");
        return delayed != null
                ? delayed.newDecapsulator(sk, spec)
                : new DelegatedDecapsulator(spi.engineNewDecapsulator(sk, spec), provider);
    }
}
