/*
 * Copyright (c) 2023, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the "Classpath" exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package javax.crypto;

import sun.security.jca.GetInstance;

import java.security.*;
import java.security.InvalidAlgorithmParameterException;
import java.security.spec.AlgorithmParameterSpec;
import java.util.List;
import java.util.Objects;

/**
 * This class provides the functionality of a Key Encapsulation Mechanism (KEM).
 * A KEM can be used to secure symmetric keys using asymmetric or public key
 * cryptography.
 * <p>
 * The {@code getInstance} method creates a new {@code KEM} object that
 * implements the specified algorithm.
 * <p>
 * A {@code KEM} object is immutable. It is safe to call multiple
 * {@code newEncapsulator} and {@code newDecapsulator} methods on the
 * same {@code KEM} object at the same time.
 * <p>
 * If a provider is not specified in the {@code getInstance} method when
 * instantiating a {@code KEM} object, the {@code newEncapsulator} and
 * {@code newDecapsulator} method may return encapsulators or decapsulators
 * from different providers. The provider selected is based on the parameters
 * passed to the the {@code newEncapsulator} or {@code newDecapsulator} methods:
 * the private or public key and the optional {@code AlgorithmParameterSpec}.
 * The {@link Encapsulator#provider} and {@link Decapsulator#provider} methods
 * return the selected provider."
 * <p>
 * {@code Encapsulator} and {@code Decapsulator} objects are immutable.
 * It is safe to invoke multiple {@code encapsulate} and {@code decapsulate}
 * methods on the same object at the same time. Each invocation of
 * {@code encapsulate} will generate a new shared secret and key encapsulation
 * message.
 * <p>
 *
 * Example:
 * {@snippet lang = java:
 *    var kpg = KeyPairGenerator.getInstance("X25519");
 *    var kp = kpg.generateKeyPair();
 *
 *    var kem = KEM.getInstance("DHKEM");
 *    var sender = kem.newEncapsulator(kp.getPublic());
 *    var encapsulated = sender.encapsulate();
 *    var k1 = encapsulated.key();
 *
 *    var receiver = kem.newDecapsulator(kp.getPrivate());
 *    var k2 = receiver.decapsulate(encapsulated.encapsulation());
 *
 *    assert Arrays.equals(k1.getEncoded(), k2.getEncoded());
 * }
 */
public final class KEM {

    /**
     * Type for the return value of the {@link Encapsulator#encapsulate} method.
     * <p>
     * Note: the key encapsulation message can be also referred to as ciphertext.
     *
     * @param key the shared secret as a key, must not be {@code null}
     * @param encapsulation the key encapsulation message to be sent to the
     *                      receiver, must not be {@code null}
     * @param params additional parameters to be sent to the receiver,
     *               can be {@code null}. The parameters can be used to
     *               initialize an {@code AlgorithmParameters} so that the
     *               receiver may recover the {@code AlgorithmParameterSpec}
     *               used by the encapsulator.
     *
     * @see KEM#newEncapsulator(PublicKey, AlgorithmParameterSpec, SecureRandom)
     */
    public record Encapsulated(SecretKey key, byte[] encapsulation, byte[] params) {
        /**
         * Constructs an {@code Encapsulated} object.
         *
         * @param key the shared secret as a key, must not be {@code null}.
         * @param encapsulation the key encapsulation message, must not be {@code null}.
         * @param params additional parameters, can be {@code null}.
         */
        public Encapsulated {
            Objects.requireNonNull(key);
            Objects.requireNonNull(encapsulation);
        }
    }

    /**
     * A decapsulator, generated by {@link #newDecapsulator}.
     */
    public static final class Decapsulator {
        private final KEMSpi.DecapsulatorSpi d;
        private final Provider p;

        private Decapsulator(KEMSpi.DecapsulatorSpi d, Provider p) {
            assert d != null;
            assert p != null;
            this.d = d;
            this.p = p;
        }

        /**
         * Returns the provider.
         *
         * @return thr provider
         */
        public Provider provider() {
            return p;
        }

        /**
         * The key decapsulation function.
         * <p>
         * This method is equivalent to
         * {@code decapsulate(encapsulation, 0, secretSize(), "Generic")}. This
         * combination of arguments should be supported by every implementation.
         *
         * @param encapsulation the key encapsulation message from the sender
         * @return the shared secret as a {@code SecretKey} with
         *          algorithm being "Generic", not {@code null}
         * @throws DecapsulateException if an error occurs during the
         *          decapsulation process
         * @throws NullPointerException if {@code encapsulation} is {@code null}
         */
        public SecretKey decapsulate(byte[] encapsulation) throws DecapsulateException {
            return decapsulate(encapsulation, 0, secretSize(), "Generic");
        }

        /**
         * The key decapsulation function.
         *
         * @param encapsulation the key encapsulation message from the sender
         * @param from the initial index of the shared secret to be returned, inclusive
         * @param to the final index of the shared secret to be returned, exclusive.
         * @param algorithm the algorithm for the secret key returned
         * @return a portion of the shared secret as a {@code SecretKey} with
         *          the specified algorithm, not {@code null}
         * @throws DecapsulateException if an error occurs during the
         *          decapsulation process
         * @throws ArrayIndexOutOfBoundsException if {@code from < 0},
         *          {@code from > to}, or {@code to > secretSize()}
         * @throws NullPointerException if {@code encapsulation} or
         *          {@code algorithm} is {@code null}
         * @throws UnsupportedOperationException if the combination of
         *          {@code from}, {@code to}, and {@code algorithm}
         *          is not supported by the decapsulator
         */
        public SecretKey decapsulate(byte[] encapsulation,
                int from, int to, String algorithm)
                throws DecapsulateException {
            Objects.checkFromToIndex(from, to, secretSize());
            var result = d.engineDecapsulate(
                    Objects.requireNonNull(encapsulation, "null encapsulation"),
                    from, to,
                    Objects.requireNonNull(algorithm, "null algorithm"));
            assert result != null : "null engineDecapsulate result";
            return result;
        }

        /**
         * Returns the size of the shared secret.
         *
         * @return the size of the shared secret
         */
        public int secretSize() {
            int result = d.engineSecretSize();
            assert result >= 0 && result != Integer.MAX_VALUE
                    : "invalid engineSecretSize result";
            return result;
        }

        /**
         * Returns the size of the key encapsulation message.
         *
         * @return the size of the key encapsulation message
         */
        public int encapsulationSize() {
            int result = d.engineEncapsulationSize();
            assert result >= 0 && result != Integer.MAX_VALUE
                    : "invalid engineEncapsulationSize result";
            return result;
        }
    }

    /**
     * An encapsulator, generated by {@link #newEncapsulator}.
     */
    public static final class Encapsulator {

        private final KEMSpi.EncapsulatorSpi e;
        private final Provider p;

        private Encapsulator(KEMSpi.EncapsulatorSpi e, Provider p) {
            assert e != null;
            assert p != null;
            this.e = e;
            this.p = p;
        }

        /**
         * Returns the provider.
         *
         * @return thr provider
         */
        public Provider provider() {
            return p;
        }

        /**
         * The key encapsulation function.
         * <p>
         * This method is equivalent to
         * {@code encapsulate(0, secretSize(), "Generic")}. This combination
         * of arguments should be supported by every implementation.
         *
         * @return an {@link KEM.Encapsulated} object containing the full
         *          shared secret as a key with algorithm being "Generic",
         *          the key encapsulation message, and optional parameters.
         *          The return value should not be {@code null}.
         */
        public KEM.Encapsulated encapsulate() {
            return encapsulate(0, secretSize(), "Generic");
        }

        /**
         * The key encapsulation function.
         *
         * @param from the initial index of the shared secret to be returned, inclusive
         * @param to the final index of the shared secret to be returned, exclusive.
         * @param algorithm the algorithm for the secret key returned
         * @return an {@link KEM.Encapsulated} object containing a portion of
         *          the shared secret as a key with the specified algorithm,
         *          the key encapsulation message, and optional parameters.
         *          The return value should not be {@code null}.
         * @throws ArrayIndexOutOfBoundsException if {@code from < 0},
         *     {@code from > to}, or {@code to > secretSize()}
         * @throws NullPointerException if {@code algorithm} is {@code null}
         * @throws UnsupportedOperationException if the combination of
         *          {@code from}, {@code to}, and {@code algorithm}
         *          is not supported by the encapsulator
         */
        public Encapsulated encapsulate(int from, int to, String algorithm) {
            Objects.checkFromToIndex(from, to, secretSize());
            var result = e.engineEncapsulate(from, to,
                    Objects.requireNonNull(algorithm, "null algorithm"));
            assert result != null : "null engineEncapsulate result";
            return result;
        }

        /**
         * Returns the size of the shared secret.
         *
         * @return the size of the shared secret
         */
        public int secretSize() {
            int result = e.engineSecretSize();
            assert result >= 0 && result != Integer.MAX_VALUE
                    : "invalid engineSecretSize result";
            return result;
        }

        /**
         * Returns the size of the key encapsulation message.
         *
         * @return the size of the key encapsulation message
         */
        public int encapsulationSize() {
            int result = e.engineEncapsulationSize();
            assert result >= 0 && result != Integer.MAX_VALUE
                    : "invalid engineEncapsulationSize result";
            return result;
        }
    }

    private static final class DelayedKEM {

        private final Provider.Service[] list; // non empty array

        private DelayedKEM(Provider.Service[] list) {
            this.list = list;
        }

        private KEM.Encapsulator newEncapsulator(PublicKey pk,
                AlgorithmParameterSpec spec, SecureRandom secureRandom)
                throws InvalidAlgorithmParameterException, InvalidKeyException {
            RuntimeException re = null;
            InvalidAlgorithmParameterException iape = null;
            InvalidKeyException ike = null;
            NoSuchAlgorithmException nsae = null;
            for (Provider.Service service : list) {
                if (!service.supportsParameter(pk)) {
                    continue;
                }
                try {
                    KEMSpi spi = (KEMSpi) service.newInstance(null);
                    return new Encapsulator(
                            spi.engineNewEncapsulator(pk, spec, secureRandom),
                            service.getProvider());
                } catch (NoSuchAlgorithmException e) {
                    nsae = merge(nsae, e);
                } catch (InvalidAlgorithmParameterException e) {
                    iape = merge(iape, e);
                } catch (InvalidKeyException e) {
                    ike = merge(ike, e);
                } catch (RuntimeException e) {
                    re = merge(re, e);
                }
            }
            if (iape != null) throw iape;
            if (ike != null) throw ike;
            if (nsae != null) {
                throw new InvalidKeyException("No installed provider found", nsae);
            }
            throw new InvalidKeyException("No installed provider supports this key: "
                            + pk.getClass().getName(), re);
        }

        private static <T extends Exception> T merge(T e1, T e2) {
            if (e1 == null) {
                return e2;
            } else {
                e1.addSuppressed(e2);
                return e1;
            }
        }

        private KEM.Decapsulator newDecapsulator(PrivateKey sk, AlgorithmParameterSpec spec)
                throws InvalidAlgorithmParameterException, InvalidKeyException {
            RuntimeException re = null;
            InvalidAlgorithmParameterException iape = null;
            InvalidKeyException ike = null;
            NoSuchAlgorithmException nsae = null;
            for (Provider.Service service : list) {
                if (!service.supportsParameter(sk)) {
                    continue;
                }
                try {
                    KEMSpi spi = (KEMSpi) service.newInstance(null);
                    return new Decapsulator(
                            spi.engineNewDecapsulator(sk, spec),
                            service.getProvider());
                } catch (NoSuchAlgorithmException e) {
                    nsae = merge(nsae, e);
                } catch (InvalidAlgorithmParameterException e) {
                    iape = merge(iape, e);
                } catch (InvalidKeyException e) {
                    ike = merge(ike, e);
                } catch (RuntimeException e) {
                    re = merge(re, e);
                }
            }
            if (iape != null) throw iape;
            if (ike != null) throw ike;
            if (nsae != null) {
                throw new InvalidKeyException("No installed provider found", nsae);
            }
            throw new InvalidKeyException("No installed provider supports this key: "
                    + sk.getClass().getName(), re);
        }
    }

    // If delayed provider selection is needed
    private final DelayedKEM delayed;

    // otherwise
    private final KEMSpi spi;
    private final Provider provider;

    private final String algorithm;

    private KEM(String algorithm, KEMSpi spi, Provider provider) {
        assert spi != null;
        assert provider != null;
        this.delayed = null;
        this.spi = spi;
        this.provider = provider;
        this.algorithm = algorithm;
    }

    private KEM(String algorithm, DelayedKEM delayed) {
        assert delayed != null;
        this.delayed = delayed;
        this.spi = null;
        this.provider = null;
        this.algorithm = algorithm;
    }

    /**
     * Returns a {@code KEM} object that implements the specified algorithm.
     *
     * @param algorithm the name of the KEM algorithm.
     *          See the {@code KEM} section in the <a href=
     *          "{@docRoot}/../specs/security/standard-names.html#kem-algorithms">
     *          Java Security Standard Algorithm Names Specification</a>
     *          for information about standard KEM algorithm names.
     * @return the new {@code KEM} object
     * @throws NoSuchAlgorithmException if no {@code Provider} supports a
     *         {@code KEM} implementation for the specified algorithm
     * @throws NullPointerException if the input argument is {@code null}
     */
    public static KEM getInstance(String algorithm)
            throws NoSuchAlgorithmException {
        List<Provider.Service> list = GetInstance.getServices(
                "KEM",
                Objects.requireNonNull(algorithm, "null algorithm name"));
        if (list.isEmpty()) {
            throw new NoSuchAlgorithmException(algorithm + " KEM not available");
        }
        return new KEM(algorithm, new DelayedKEM(list.toArray(new Provider.Service[0])));
    }

    /**
     * Returns a {@code KEM} object that implements the specified algorithm
     * from the specified security provider.
     *
     * @param algorithm the name of the KEM algorithm.
     *          See the {@code KEM} section in the <a href=
     *          "{@docRoot}/../specs/security/standard-names.html#kem-algorithms">
     *          Java Security Standard Algorithm Names Specification</a>
     *          for information about standard KEM algorithm names.
     * @param provider the provider. If {@code null}, this method is equivalent
     *                 to {@link #getInstance(String)}.
     * @return the new {@code KEM} object
     * @throws NoSuchAlgorithmException if a {@code provider} is specified and
     *          it does not support the specified KEM algorithm,
     *          or if {@code provider} is {@code null} and there is no provider
     *          that supports a KEM implementation of the specified algorithm
     * @throws NullPointerException if {@code algorithm} is {@code null}
     */
    public static KEM getInstance(String algorithm, Provider provider)
            throws NoSuchAlgorithmException {
        if (provider == null) {
            return getInstance(algorithm);
        }
        GetInstance.Instance instance = GetInstance.getInstance(
                "KEM",
                KEMSpi.class,
                Objects.requireNonNull(algorithm, "null algorithm name"),
                provider);
        return new KEM(algorithm, (KEMSpi) instance.impl, instance.provider);
    }

    /**
     * Returns a {@code KEM} object that implements the specified algorithm
     * from the specified security provider.
     *
     * @param algorithm the name of the KEM algorithm.
     *          See the {@code KEM} section in the <a href=
     *          "{@docRoot}/../specs/security/standard-names.html#kem-algorithms">
     *          Java Security Standard Algorithm Names Specification</a>
     *          for information about standard KEM algorithm names.
     * @param provider the provider. If {@code null}, this method is equivalent
     *                 to {@link #getInstance(String)}.
     * @return the new {@code KEM} object
     * @throws NoSuchAlgorithmException if a {@code provider} is specified and
     *          it does not support the specified KEM algorithm,
     *          or if {@code provider} is {@code null} and there is no provider
     *          that supports a KEM implementation of the specified algorithm
     * @throws NoSuchProviderException if the specified provider is not
     *         registered in the security provider list
     * @throws NullPointerException if {@code algorithm} is {@code null}
     */
    public static KEM getInstance(String algorithm, String provider)
            throws NoSuchAlgorithmException, NoSuchProviderException {
        if (provider == null) {
            return getInstance(algorithm);
        }
        GetInstance.Instance instance = GetInstance.getInstance(
                "KEM",
                KEMSpi.class,
                Objects.requireNonNull(algorithm, "null algorithm name"),
                provider);
        return new KEM(algorithm, (KEMSpi) instance.impl, instance.provider);
    }

    /**
     * Creates a KEM encapsulator.
     * <p>
     * This method is equivalent to {@code newEncapsulator(pk, null, null)}.
     *
     * @param pk the receiver's public key, must not be {@code null}
     * @return the encapsulator for this key
     * @throws InvalidKeyException if {@code pk} is invalid
     * @throws NullPointerException if {@code pk} is {@code null}
     * @throws UnsupportedOperationException if this method is not supported
     *          because an {@code AlgorithmParameterSpec} must be provided
     */
    public Encapsulator newEncapsulator(PublicKey pk)
            throws InvalidKeyException {
        try {
            return newEncapsulator(pk, null, null);
        } catch (InvalidAlgorithmParameterException e) {
            throw new UnsupportedOperationException(
                    "AlgorithmParameterSpec must be provided", e);
        }
    }

    /**
     * Creates a KEM encapsulator.
     * <p>
     * This method is equivalent to {@code newEncapsulator(pk, null, secureRandom)}.
     *
     * @param pk the receiver's public key, must not be {@code null}
     * @param secureRandom the source of randomness for encapsulation.
     *                     If {@code} null, a default one from the
     *                     implementation will be used.
     * @return the encapsulator for this key, not {@code null}
     * @throws InvalidKeyException if {@code pk} is invalid
     * @throws NullPointerException if {@code pk} is {@code null}
     * @throws UnsupportedOperationException if this method is not supported
     *          because an {@code AlgorithmParameterSpec} must be provided
     */
    public Encapsulator newEncapsulator(PublicKey pk, SecureRandom secureRandom)
            throws InvalidKeyException {
        try {
            return newEncapsulator(pk, null, secureRandom);
        } catch (InvalidAlgorithmParameterException e) {
            throw new UnsupportedOperationException(
                    "AlgorithmParameterSpec must be provided", e);
        }
    }

    /**
     * Creates a KEM encapsulator.
     * <p>
     * An algorithm can define an {@code AlgorithmParameterSpec} child class to
     * provide extra information in this method. This is especially useful if
     * the same key can be used to derive shared secrets in different ways.
     * If any extra information inside this object needs to be transmitted along
     * with the key encapsulation message so that the receiver is able to create
     * a matching decapsulator, it will be included as a byte array in the
     * {@link Encapsulated#params} field inside the encapsulation output.
     * In this case, the security provider should provide an
     * {@code AlgorithmParameters} implementation using the same algorithm name
     * as the KEM. The receiver can initiate such an {@code AlgorithmParameters}
     * instance with the {@code params} byte array received and recover
     * an {@code AlgorithmParameterSpec} object to be used in its
     * {@link #newDecapsulator(PrivateKey, AlgorithmParameterSpec)} call.
     *
     * @param pk the receiver's public key, must not be {@code null}
     * @param spec the optional parameter, can be {@code null}
     * @param secureRandom the source of randomness for encapsulation.
     *                     If {@code} null, a default one from the
     *                     implementation will be used.
     * @return the encapsulator for this key, not {@code null}
     * @throws InvalidAlgorithmParameterException if {@code spec} is invalid
     *          or one is required but {@code spec} is {@code null}
     * @throws InvalidKeyException if {@code pk} is invalid
     * @throws NullPointerException if {@code pk} is {@code null}
     */
    public Encapsulator newEncapsulator(PublicKey pk,
            AlgorithmParameterSpec spec, SecureRandom secureRandom)
            throws InvalidAlgorithmParameterException, InvalidKeyException {
        Objects.requireNonNull(pk, "null public key");
        return delayed != null
                ? delayed.newEncapsulator(pk, spec, secureRandom)
                : new Encapsulator(spi.engineNewEncapsulator(pk, spec, secureRandom), provider);
    }

    /**
     * Creates a KEM decapsulator.
     * <p>
     * This method is equivalent to {@code newDecapsulator(sk, null)}.
     *
     * @param sk the receiver's private key, must not be {@code null}
     * @return the decapsulator for this key, not {@code null}
     * @throws InvalidKeyException if {@code sk} is invalid
     * @throws NullPointerException if {@code sk} is {@code null}
     * @throws UnsupportedOperationException if this method is not supported
     *          because an {@code AlgorithmParameterSpec} must be provided
     */
    public Decapsulator newDecapsulator(PrivateKey sk)
            throws InvalidKeyException {
        try {
            return newDecapsulator(sk, null);
        } catch (InvalidAlgorithmParameterException e) {
            throw new UnsupportedOperationException(e);
        }
    }

    /**
     * Creates a KEM decapsulator.
     *
     * @param sk the receiver's private key, must not be {@code null}
     * @param spec the parameter, can be {@code null}
     * @return the decapsulator for this key, not {@code null}
     * @throws InvalidAlgorithmParameterException if {@code spec} is invalid
     *          or one is required but {@code spec} is {@code null}
     * @throws InvalidKeyException if {@code sk} is invalid
     * @throws NullPointerException if {@code sk} is {@code null}
     */
    public Decapsulator newDecapsulator(PrivateKey sk, AlgorithmParameterSpec spec)
            throws InvalidAlgorithmParameterException, InvalidKeyException {
        Objects.requireNonNull(sk, "null private key");
        return delayed != null
                ? delayed.newDecapsulator(sk, spec)
                : new Decapsulator(spi.engineNewDecapsulator(sk, spec), provider);
    }

    /**
     * Returns the name of the algorithm for this {@code KEM} object.
     *
     * @return the name of the algorithm for this {@code KEM} object.
     */
    public String getAlgorithm() {
        return this.algorithm;
    }
}
