/*
 * Copyright (c) 2023, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the "Classpath" exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package javax.crypto;

import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.SecureRandom;
import java.security.spec.AlgorithmParameterSpec;

/**
 * This class defines the Service Provider Interface (SPI) for the {@link KEM}
 * class. A security provider implements this interface to provide an
 * implementation of a Key Encapsulation Mechanism (KEM) algorithm.
 * <p>
 * A KEM algorithm may support a family of configurations. Each configuration
 * may accept different types of keys, cryptographic primitives, and sizes of
 * shared secrets and key encapsulation messages. A configuration is defined
 * by the KEM algorithm name, the key it uses, and an optional
 * {@code AlgorithmParameterSpec} argument that is specified when creating
 * an encapsulator or decapsulator. The result of calling
 * {@link #engineNewEncapsulator} or {@link #engineNewDecapsulator} must return
 * an encapsulator or decapsulator that maps to a single configuration,
 * where its {@link EncapsulatorSpi#engineSecretSize()} and
 * {@link EncapsulatorSpi#engineEncapsulationSize()} methods return constant
 * values.
 * <p>
 * A {@code KEMSpi} implementation must be immutable. It must be safe to
 * call multiple {@code engineNewEncapsulator} and {@code engineNewDecapsulator}
 * methods at the same time.
 * <p>
 * {@code EncapsulatorSpi} and {@code DecapsulatorSpi} implementations must also
 * be immutable. It must be safe to invoke multiple {@code encapsulate} and
 * {@code decapsulate} methods at the same time. Each invocation of
 * {@code encapsulate} should generate a new shared secret and key
 * encapsulation message.
 * <p>
 * For example,
 * {@snippet lang = java:
 * public static class MyKEMImpl implements KEMSpi {
 *
 *     @Override
 *     public KEMSpi.EncapsulatorSpi engineNewEncapsulator(PublicKey pk,
 *             AlgorithmParameterSpec spec, SecureRandom secureRandom)
 *             throws InvalidAlgorithmParameterException, InvalidKeyException {
 *         if (!checkPublicKey(pk)) {
 *             throw new InvalidKeyException("unsupported key");
 *         }
 *         if (!checkParameters(spec)) {
 *             throw new InvalidAlgorithmParameterException("unsupported params");
 *         }
 *         return new MyEncapsulator(pk, spec, secureRandom);
 *     }
 *
 *     class MyEncapsulator implements KEMSpi.EncapsulatorSpi {
 *         MyEncapsulator(PublicKey pk, AlgorithmParameterSpec spec, SecureRandom secureRandom){
 *             this.spec = spec != null ? spec : getDefaultParameters();
 *             this.secureRandom = secureRandom != null ? secureRandom : getDefaultSecureRandom();
 *             this.pk = pk;
 *         }
 *
 *         @Override
 *         public KEM.Encapsulated encapsulate(int from, int to, String algorithm) {
 *             // ...
 *         }
 *
 *         // ...
 *     }
 *
 *     // ...
 * }
 * }
 *
 * @see KEM
 * @since 21
 */
public interface KEMSpi {

    /**
     * The KEM encapsulator implementation, generated by
     * {@link #engineNewEncapsulator}.
     *
     * @see KEM.Encapsulator
     */
    interface EncapsulatorSpi {
        /**
         * The key encapsulation function.
         * <p>
         * An implementation must support the case where {@code from} is 0,
         * {@code from} is the same as the output of {@code secretSize()},
         * and {@code algorithm} is "Generic".
         *
         * @param from the initial index of the shared secret byte array
         *          to be returned, inclusive
         * @param to the final index of the shared secret byte array
         *          to be returned, exclusive
         * @param algorithm the algorithm name for the secret key that is returned
         * @return an {@link KEM.Encapsulated} object containing a portion of
         *          the shared secret as a key with the specified algorithm,
         *          the key encapsulation message, and optional parameters.
         * @throws ArrayIndexOutOfBoundsException if {@code from < 0},
         *     {@code from > to}, or {@code to > secretSize()}
         * @throws NullPointerException if {@code algorithm} is {@code null}
         * @throws UnsupportedOperationException if the combination of
         *          {@code from}, {@code to}, and {@code algorithm}
         *          is not supported by the encapsulator
         * @see KEM.Encapsulated
         * @see KEM.Encapsulator#encapsulate(int, int, String)
         */
        KEM.Encapsulated engineEncapsulate(int from, int to, String algorithm);

        /**
         * Returns the size of the shared secret.
         * <p>
         * This method can be called to find out the length of the share secret
         * before {@code engineEncapsulate} is called or if the obtained
         * {@code SecretKey} is not extractable.
         *
         * @return the size of the shared secret as a finite non-negative integer
         * @see KEM.Encapsulator#secretSize()
         */
        int engineSecretSize();

        /**
         * Returns the size of the key encapsulation message.
         * <p>
         * This method can be called to find out the length of the encapsulation
         * message before {@code engineEncapsulate} is called.
         *
         * @return the size of the key encapsulation message as a finite non-negative integer
         * @see KEM.Encapsulator#encapsulationSize()
         */
        int engineEncapsulationSize();
    }

    /**
     * The KEM decapsulator implementation, generated by
     * {@link #engineNewDecapsulator}.
     *
     * @see KEM.Decapsulator
     */
    interface DecapsulatorSpi {
        /**
         * The key decapsulation function.
         * <p>
         * An implementation must support the case where {@code from} is 0,
         * {@code from} is the same as the output of {@code secretSize()},
         * and {@code algorithm} is "Generic".
         *
         * @param encapsulation the key encapsulation message from the sender.
         *          The size must be equal to the value returned by
         *          {@link #engineEncapsulationSize()} ()}, or a
         *          {@code DecapsulateException} must be thrown.
         * @param from the initial index of the shared secret byte array
         *          to be returned, inclusive
         * @param to the final index of the shared secret byte array
         *          to be returned, exclusive
         * @param algorithm the algorithm name for the secret key that is returned
         * @return a portion of the shared secret as a {@code SecretKey} with
         *          the specified algorithm
         * @throws DecapsulateException if an error occurs during the
         *          decapsulation process
         * @throws ArrayIndexOutOfBoundsException if {@code from < 0},
         *          {@code from > to}, or {@code to > secretSize()}
         * @throws NullPointerException if {@code encapsulation} or
         *          {@code algorithm} is {@code null}
         * @throws UnsupportedOperationException if the combination of
         *          {@code from}, {@code to}, and {@code algorithm}
         *          is not supported by the decapsulator
         * @see KEM.Decapsulator#decapsulate(byte[], int, int, String)
         */
        SecretKey engineDecapsulate(byte[] encapsulation, int from, int to, String algorithm)
                throws DecapsulateException;

        /**
         * Returns the size of the shared secret.
         * <p>
         * This method can be called to find out the length of the share secret
         * before {@code engineDecapsulate} is called or if the obtained
         * {@code SecretKey} is not extractable.
         *
         * @return the size of the shared secret as a finite non-negative integer
         * @see KEM.Decapsulator#secretSize()
         */
        int engineSecretSize();

        /**
         * Returns the size of the key encapsulation message.
         * <p>
         * This method can be used to extract the encapsulation message
         * from a longer byte array if no length information is provided
         * by a higher level protocol.
         *
         * @return the size of the key encapsulation message as a finite non-negative integer
         * @see KEM.Decapsulator#encapsulationSize()
         */
        int engineEncapsulationSize();
    }

    /**
     * Creates a KEM encapsulator.
     *
     * @param pk the receiver's public key, must not be {@code null}
     * @param spec the optional parameter, can be {@code null}
     * @param secureRandom the source of randomness for encapsulation.
     *                     If {@code null}, the implementation must provide
     *                     a default one.
     * @return the encapsulator for this key
     * @throws InvalidAlgorithmParameterException if {@code spec} is invalid
     *          or one is required but {@code spec} is {@code null}
     * @throws InvalidKeyException if {@code pk} is invalid
     * @see KEM#newEncapsulator(PublicKey, AlgorithmParameterSpec, SecureRandom)
     */
    EncapsulatorSpi engineNewEncapsulator(PublicKey pk,
            AlgorithmParameterSpec spec, SecureRandom secureRandom)
            throws InvalidAlgorithmParameterException, InvalidKeyException;

    /**
     * Creates a KEM decapsulator.
     *
     * @param sk the receiver's private key, must not be {@code null}
     * @param spec the parameter, can be {@code null}
     * @return the decapsulator for this key
     * @throws InvalidAlgorithmParameterException if {@code spec} is invalid
     *          or one is required but {@code spec} is {@code null}
     * @throws InvalidKeyException if {@code sk} is invalid
     * @see KEM#newDecapsulator(PrivateKey, AlgorithmParameterSpec)
     */
    DecapsulatorSpi engineNewDecapsulator(PrivateKey sk, AlgorithmParameterSpec spec)
            throws InvalidAlgorithmParameterException, InvalidKeyException;
}
