// Hide secondary edges.
remove("short_name", "FP|RA|IO");
removeInputs("name", "Root");
new RemoveSelfLoopsFilter("Remove Self-Loops").apply(graph);
removeInputs("name", "SafePoint|CallStaticJava|CallDynamicJava|CallJava|CallLeaf|CallRuntime|AbstractLock|CallLeafNoFP|Call|CallStaticJavaDirect", 5);
removeInputs("name", "Halt", 1);
removeInputs("name", "Unlock|Lock", 7);
removeInputs("name", "Allocate", 7);
removeInputs("name", "AllocateArray", 9);

// Inline Parm and start MachProj nodes, except control ones.
new SplitFilter("", new AndSelector(new MatcherSelector(new Properties.RegexpPropertyMatcher("name", "Parm|MachProj")),
                                    new InvertSelector(new MatcherSelector(new Properties.RegexpPropertyMatcher("category", "control"))),
                                    new SuccessorSelector(new MatcherSelector(new Properties.RegexpPropertyMatcher("name", "Start")))),
                "[short_name]").apply(graph);

// Combine single-input nodes.
var anyNode = new Properties.RegexpPropertyMatcher("name", ".*");
var f = new CombineFilter("Combine Filter");
f.addRule(new CombineFilter.CombineRule(anyNode, new Properties.RegexpPropertyMatcher("name", "Proj|IfFalse|IfTrue|JProj|MachProj|JumpProj|CatchProj|Parm")));
f.addRule(new CombineFilter.CombineRule(anyNode, new Properties.RegexpPropertyMatcher("name", "SCMemProj"), false, "SCM"));
f.addRule(new CombineFilter.CombineRule(new Properties.RegexpPropertyMatcher("name", "Cmp.*"), new Properties.RegexpPropertyMatcher("name", "Bool"), false, "[short_name]", "[dump_spec]"));
f.addRule(new CombineFilter.CombineRule(anyNode, new Properties.RegexpPropertyMatcher("name", "Decode(N|NarrowPtr|NKlass)"), false, "DC"));
f.addRule(new CombineFilter.CombineRule(anyNode, new Properties.RegexpPropertyMatcher("name", "Conv2B"), false, "2B"));
f.addRule(new CombineFilter.CombineRule(anyNode, new Properties.RegexpPropertyMatcher("name", "Conv[LFD]2I"), false, "2I"));
f.addRule(new CombineFilter.CombineRule(anyNode, new Properties.RegexpPropertyMatcher("name", "Conv[IFD]2L"), false, "2L"));
f.addRule(new CombineFilter.CombineRule(anyNode, new Properties.RegexpPropertyMatcher("name", "Conv[ILD]2F"), false, "2F"));
f.addRule(new CombineFilter.CombineRule(anyNode, new Properties.RegexpPropertyMatcher("name", "Conv[ILF]2D"), false, "2D"));
f.apply(graph);

// Inline (split) constant nodes.
split("name", "BoxLock");
new SplitFilter("", new MatcherSelector(new Properties.RegexpPropertyMatcher("name", "MachTemp")), "T").apply(graph);
new SplitFilter("", new MatcherSelector(new Properties.RegexpPropertyMatcher("name", "ThreadLocal")), "TL").apply(graph);
new SplitFilter("", new MatcherSelector(new Properties.RegexpPropertyMatcher("name", "(Con[A-Z]?)|ConNKlass|(loadCon.*)")), "[short_name]", "[name]").apply(graph);
