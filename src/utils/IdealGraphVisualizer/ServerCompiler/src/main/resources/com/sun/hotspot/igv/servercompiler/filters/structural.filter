// Remove self-loops.
new RemoveSelfLoopsFilter("Remove Self-Loops").apply(graph);

// Hide secondary edges.
remove("short_name", "FP|RA|IO|RP");

// Condense inputs for all nodes.
var anyNode = new Properties.RegexpPropertyMatcher("name", ".*");
var f = new RemoveInputsFilter("");
f.addRule(new RemoveInputsFilter.RemoveInputsRule(new MatcherSelector(new Properties.RegexpPropertyMatcher("name", "Root")), new MatcherSelector(anyNode)));
f.apply(graph);

var fun = new MatcherSelector(new Properties.RegexpPropertyMatcher("name", "SafePoint|CallStaticJava|CallDynamicJava|CallJava|CallLeaf|CallRuntime|AbstractLock|CallLeafNoFP|Call|CallStaticJavaDirect"));
var topCon = new AndSelector(new MatcherSelector(new Properties.RegexpPropertyMatcher("name", "Con")),
                                                 new MatcherSelector(new Properties.RegexpPropertyMatcher("type", "top")));
var f = new RemoveInputsFilter("");
f.addRule(new RemoveInputsFilter.RemoveInputsRule(fun, new OrSelector(topCon, new MatcherSelector(new Properties.RegexpPropertyMatcher("short_name", "I")))));
f.apply(graph);

var other = new MatcherSelector(new Properties.RegexpPropertyMatcher("name", "Halt|Rethrow|ShouldNotReachHere|RethrowException|Return|Ret|MergeMem|Initialize|MemBarRelease|Unlock|Lock|Allocate|AllocateArray"));
var f = new RemoveInputsFilter("");
f.addRule(new RemoveInputsFilter.RemoveInputsRule(other, topCon));
f.apply(graph);

new RemoveEmptySlotsFilter("", new MatcherSelector(anyNode)).apply(graph);

// Inline Parm and start MachProj nodes, except control ones.
new SplitFilter("", new AndSelector(new MatcherSelector(new Properties.RegexpPropertyMatcher("name", "Parm|MachProj")),
                                    new InvertSelector(new MatcherSelector(new Properties.RegexpPropertyMatcher("category", "control"))),
                                    new SuccessorSelector(new MatcherSelector(new Properties.RegexpPropertyMatcher("name", "Start")))),
                "[short_name]").apply(graph);

// Combine single-input nodes.
var f = new CombineFilter("Combine Filter");
f.addRule(new CombineFilter.CombineRule(anyNode, new Properties.RegexpPropertyMatcher("name", "Proj|IfFalse|IfTrue|JProj|MachProj|JumpProj|CatchProj|Parm")));
f.addRule(new CombineFilter.CombineRule(anyNode, new Properties.RegexpPropertyMatcher("name", "SCMemProj"), false, "SCM"));
f.addRule(new CombineFilter.CombineRule(new Properties.RegexpPropertyMatcher("name", "Cmp.*"), new Properties.RegexpPropertyMatcher("name", "Bool"), false, "[short_name]", "[dump_spec]"));
f.addRule(new CombineFilter.CombineRule(anyNode, new Properties.RegexpPropertyMatcher("name", "Decode(N|NarrowPtr|NKlass)"), false, "DC"));
f.addRule(new CombineFilter.CombineRule(anyNode, new Properties.RegexpPropertyMatcher("name", "Conv2B"), false, "2B"));
f.addRule(new CombineFilter.CombineRule(anyNode, new Properties.RegexpPropertyMatcher("name", "Conv[LFD]2I"), false, "2I"));
f.addRule(new CombineFilter.CombineRule(anyNode, new Properties.RegexpPropertyMatcher("name", "Conv[IFD]2L"), false, "2L"));
f.addRule(new CombineFilter.CombineRule(anyNode, new Properties.RegexpPropertyMatcher("name", "Conv[ILD]2F"), false, "2F"));
f.addRule(new CombineFilter.CombineRule(anyNode, new Properties.RegexpPropertyMatcher("name", "Conv[ILF]2D"), false, "2D"));
f.apply(graph);

// Inline (split) constant nodes.
split("name", "BoxLock");
new SplitFilter("", new MatcherSelector(new Properties.RegexpPropertyMatcher("name", "MachTemp")), "T").apply(graph);
new SplitFilter("", new MatcherSelector(new Properties.RegexpPropertyMatcher("name", "ThreadLocal")), "TL").apply(graph);
new SplitFilter("", new MatcherSelector(new Properties.RegexpPropertyMatcher("name", "(Con[A-Z]?)|ConNKlass|(loadCon.*)")), "[short_name]", "[name]").apply(graph);
