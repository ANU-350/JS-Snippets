// Remove self-loops.
new RemoveSelfLoopsFilter("Remove Self-Loops").apply(graph);

// Hide secondary edges.
remove("short_name", "FP|RA|IO|RP");

// Condense inputs for all nodes.
var anyNode = new Properties.RegexpPropertyMatcher("name", ".*");
var f = new RemoveInputsFilter("");
f.addRule(new RemoveInputsFilter.RemoveInputsRule(matches("name", "Root"), new MatcherSelector(anyNode)));
f.apply(graph);

var fun = matches("name", "SafePoint|CallStaticJava|CallDynamicJava|CallJava|CallLeaf|CallRuntime|AbstractLock|CallLeafNoFP|Call|CallStaticJavaDirect");
var topCon = and([matches("name", "Con"),
                  matches("type", "top")]);
var f = new RemoveInputsFilter("");
f.addRule(new RemoveInputsFilter.RemoveInputsRule(fun, or([topCon, matches("short_name", "I")])));
f.apply(graph);

var other = matches("name", "Halt|Rethrow|ShouldNotReachHere|RethrowException|Return|Ret|MergeMem|Initialize|MemBarAcquire|MemBarRelease|Unlock|Lock|Allocate|AllocateArray");
var f = new RemoveInputsFilter("");
f.addRule(new RemoveInputsFilter.RemoveInputsRule(other, topCon));
f.apply(graph);

new RemoveEmptySlotsFilter("", new MatcherSelector(anyNode)).apply(graph);

// Inline Parm and start MachProj nodes, except control ones.
new SplitFilter("", and([matches("name", "Parm|MachProj"),
                         new InvertSelector(matches("category", "control")),
                         new SuccessorSelector(matches("name", "Start"))]),
                "[short_name]").apply(graph);

// Combine single-input nodes.
var f = new CombineFilter("Combine Filter");
f.addRule(new CombineFilter.CombineRule(anyNode, new Properties.RegexpPropertyMatcher("name", "Proj|IfFalse|IfTrue|JProj|MachProj|JumpProj|CatchProj|Parm")));
f.addRule(new CombineFilter.CombineRule(anyNode, new Properties.RegexpPropertyMatcher("name", "SCMemProj"), false, "SCM"));
f.addRule(new CombineFilter.CombineRule(new Properties.RegexpPropertyMatcher("name", "Cmp.*"), new Properties.RegexpPropertyMatcher("name", "Bool"), false, "[short_name]", "[dump_spec]"));
f.addRule(new CombineFilter.CombineRule(anyNode, new Properties.RegexpPropertyMatcher("name", "Decode(N|NarrowPtr|NKlass)"), false, "DC"));
f.addRule(new CombineFilter.CombineRule(anyNode, new Properties.RegexpPropertyMatcher("name", "Conv2B"), false, "2B"));
f.addRule(new CombineFilter.CombineRule(anyNode, new Properties.RegexpPropertyMatcher("name", "Conv[LFD]2I"), false, "2I"));
f.addRule(new CombineFilter.CombineRule(anyNode, new Properties.RegexpPropertyMatcher("name", "Conv[IFD]2L"), false, "2L"));
f.addRule(new CombineFilter.CombineRule(anyNode, new Properties.RegexpPropertyMatcher("name", "Conv[ILD]2F"), false, "2F"));
f.addRule(new CombineFilter.CombineRule(anyNode, new Properties.RegexpPropertyMatcher("name", "Conv[ILF]2D"), false, "2D"));
f.apply(graph);

// Inline (split) constant nodes.
split("name", "BoxLock");
new SplitFilter("", matches("name", "MachTemp"), "T").apply(graph);
new SplitFilter("", matches("name", "ThreadLocal"), "TL").apply(graph);
new SplitFilter("", matches("name", "(Con[A-Z]?)|ConNKlass|(loadCon.*)"), "[short_name]", "[name]").apply(graph);
