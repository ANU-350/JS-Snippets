// Hide secondary edges.
remove("dump_spec", "FramePtr|ReturnAdr|I_O");
removeInputs("name", "Root");
new RemoveSelfLoopsFilter("Remove Self-Loops").apply(graph);
removeInputs("name", "SafePoint|CallStaticJava|CallDynamicJava|CallJava|CallLeaf|CallRuntime|AbstractLock|CallLeafNoFP|Call|CallStaticJavaDirect", 5);
removeInputs("name", "Unlock|Lock", 7);
removeInputs("name", "Allocate", 7);
removeInputs("name", "AllocateArray", 9);

// Combine single-input nodes.
var anyNode = new Properties.RegexpPropertyMatcher("name", ".*");
var f = new CombineFilter("Combine Filter");
f.addRule(new CombineFilter.CombineRule(anyNode, new Properties.RegexpPropertyMatcher("name", "Proj|IfFalse|IfTrue|JProj|MachProj|JumpProj|CatchProj|Parm")));
f.addRule(new CombineFilter.CombineRule(new Properties.RegexpPropertyMatcher("name", "Cmp.*"), new Properties.RegexpPropertyMatcher("name", "Bool"), false, "[short_name]", "[dump_spec]"));
f.addRule(new CombineFilter.CombineRule(anyNode, new Properties.RegexpPropertyMatcher("name", "Decode(N|NarrowPtr|NKlass)"), false, "DC"));
f.addRule(new CombineFilter.CombineRule(anyNode, new Properties.RegexpPropertyMatcher("name", "Conv[LFD]2I"), false, "2I"));
f.addRule(new CombineFilter.CombineRule(anyNode, new Properties.RegexpPropertyMatcher("name", "Conv[IFD]2L"), false, "2L"));
f.addRule(new CombineFilter.CombineRule(anyNode, new Properties.RegexpPropertyMatcher("name", "Conv[ILD]2F"), false, "2F"));
f.addRule(new CombineFilter.CombineRule(anyNode, new Properties.RegexpPropertyMatcher("name", "Conv[ILF]2D"), false, "2D"));
f.apply(graph);

// Inline (split) constant nodes.
split("name", "BoxLock");
split("name", "(Con.*)|(loadCon.*)", "[dump_spec]");